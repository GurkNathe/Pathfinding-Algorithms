{"ast":null,"code":"import { getNeighbors, reconstructPath } from \"./helper\";\nexport default function dfs(colorGrid, setGrid, endPoints) {\n  let grid = [...colorGrid];\n  let stack = [];\n  let previous = {};\n  stack.push(endPoints.start);\n  let found = false;\n  while (stack.length > 0 && !found) {\n    let [y, x] = stack.pop();\n    if (grid[y][x] === \"red\") {\n      continue;\n    }\n    if (grid[y][x] !== \"orange\") {\n      grid[y][x] = \"red\";\n    }\n    for (const neighbor of getNeighbors(grid, [y, x])) {\n      let [ny, nx] = neighbor;\n      if (grid[ny][nx] !== \"red\") {\n        if (grid[ny][nx] === \"blue\") {\n          previous[`${ny}-${nx}`] = [y, x];\n          found = true;\n          reconstructPath(grid, previous, endPoints.end);\n          break;\n        } else {\n          previous[`${ny}-${nx}`] = [y, x];\n          stack.push(neighbor);\n          if (grid[ny][nx] !== \"orange\") {\n            grid[ny][nx] = \"green\";\n          }\n        }\n      }\n    }\n    setGrid(grid);\n  }\n}","map":{"version":3,"names":["getNeighbors","reconstructPath","dfs","colorGrid","setGrid","endPoints","grid","stack","previous","push","start","found","length","y","x","pop","neighbor","ny","nx","end"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/dfs.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { getNeighbors, reconstructPath } from \"./helper\";\n\nexport default function dfs(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid: States[][] = [...colorGrid];\n    let stack: [number, number][] = [];\n    let previous : any = {};\n\n    stack.push(endPoints.start);\n    \n    let found: boolean = false;\n    \n    while (stack.length > 0 && !found) {\n        let [y, x] = stack.pop()!;\n\n        if (grid[y][x] === \"red\") {\n            continue;\n        }\n\n        if (grid[y][x] !== \"orange\") {\n            grid[y][x] = \"red\";\n        }\n\n        for (const neighbor of getNeighbors(grid, [y, x])) {\n            let [ny, nx] = neighbor;\n            if (grid[ny][nx] !== \"red\") {\n                if (grid[ny][nx] === \"blue\") {\n                    previous[`${ny}-${nx}`] = [y,x];\n                    found = true;\n                    reconstructPath(grid, previous, endPoints.end);\n                    break;\n                } else {\n                    previous[`${ny}-${nx}`] = [y,x];\n                    stack.push(neighbor);\n\n                    if (grid[ny][nx] !== \"orange\") {\n                        grid[ny][nx] = \"green\"\n                    }\n                }\n            }\n        }\n        setGrid(grid)\n    }\n}"],"mappings":"AACA,SAASA,YAAY,EAAEC,eAAe,QAAQ,UAAU;AAExD,eAAe,SAASC,GAAGA,CAACC,SAAqB,EAAEC,OAAyD,EAAEC,SAAoB,EAAE;EAChI,IAAIC,IAAgB,GAAG,CAAC,GAAGH,SAAS,CAAC;EACrC,IAAII,KAAyB,GAAG,EAAE;EAClC,IAAIC,QAAc,GAAG,CAAC,CAAC;EAEvBD,KAAK,CAACE,IAAI,CAACJ,SAAS,CAACK,KAAK,CAAC;EAE3B,IAAIC,KAAc,GAAG,KAAK;EAE1B,OAAOJ,KAAK,CAACK,MAAM,GAAG,CAAC,IAAI,CAACD,KAAK,EAAE;IAC/B,IAAI,CAACE,CAAC,EAAEC,CAAC,CAAC,GAAGP,KAAK,CAACQ,GAAG,CAAC,CAAE;IAEzB,IAAIT,IAAI,CAACO,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,KAAK,EAAE;MACtB;IACJ;IAEA,IAAIR,IAAI,CAACO,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACzBR,IAAI,CAACO,CAAC,CAAC,CAACC,CAAC,CAAC,GAAG,KAAK;IACtB;IAEA,KAAK,MAAME,QAAQ,IAAIhB,YAAY,CAACM,IAAI,EAAE,CAACO,CAAC,EAAEC,CAAC,CAAC,CAAC,EAAE;MAC/C,IAAI,CAACG,EAAE,EAAEC,EAAE,CAAC,GAAGF,QAAQ;MACvB,IAAIV,IAAI,CAACW,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,KAAK,EAAE;QACxB,IAAIZ,IAAI,CAACW,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,MAAM,EAAE;UACzBV,QAAQ,CAAE,GAAES,EAAG,IAAGC,EAAG,EAAC,CAAC,GAAG,CAACL,CAAC,EAACC,CAAC,CAAC;UAC/BH,KAAK,GAAG,IAAI;UACZV,eAAe,CAACK,IAAI,EAAEE,QAAQ,EAAEH,SAAS,CAACc,GAAG,CAAC;UAC9C;QACJ,CAAC,MAAM;UACHX,QAAQ,CAAE,GAAES,EAAG,IAAGC,EAAG,EAAC,CAAC,GAAG,CAACL,CAAC,EAACC,CAAC,CAAC;UAC/BP,KAAK,CAACE,IAAI,CAACO,QAAQ,CAAC;UAEpB,IAAIV,IAAI,CAACW,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,QAAQ,EAAE;YAC3BZ,IAAI,CAACW,EAAE,CAAC,CAACC,EAAE,CAAC,GAAG,OAAO;UAC1B;QACJ;MACJ;IACJ;IACAd,OAAO,CAACE,IAAI,CAAC;EACjB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}