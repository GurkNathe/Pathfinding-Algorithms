{"ast":null,"code":"import { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\nexport default function gbls(colorGrid, setGrid, endPoints) {\n  let grid = [...colorGrid];\n  let queue = new PriorityQueue();\n  queue.enqueue(endPoints.start, heuristic(\"manhattan\", grid, endPoints.start, endPoints.end), 0);\n  let count = 0;\n  let found = false;\n  let previous = {};\n  let lastdir = [-1, -1];\n  while (!queue.isEmpty() && !found) {\n    let [y, x] = queue.dequeue();\n    if (grid[y][x] === \"red\") {\n      continue;\n    }\n    if (grid[y][x] !== \"orange\" && grid[y][x] !== \"blue\") {\n      grid[y][x] = \"red\";\n    }\n    let neighbors = getNeighbors(grid, [y, x]);\n    if (lastdir[0] !== -1) {\n      let tempNeighbors = neighbors.filter(n => n[0] - y === lastdir[0] && n[1] - x === lastdir[1]);\n      for (const n of neighbors) {\n        let i = tempNeighbors.findIndex(item => item[0] === n[0] && item[1] === n[1]);\n        if (i === -1) {\n          tempNeighbors.push(n);\n        }\n      }\n      neighbors = tempNeighbors;\n    }\n    for (const neighbor of neighbors) {\n      let [ny, nx] = neighbor;\n      if (grid[ny][nx] !== \"red\") {\n        if (grid[ny][nx] === \"blue\") {\n          previous[`${ny}-${nx}`] = [y, x];\n          found = true;\n          reconstructPath(grid, previous, endPoints.end);\n          break;\n        }\n        if (grid[ny][nx] !== \"orange\") {\n          grid[ny][nx] = \"green\";\n        }\n        count++;\n        let distance = heuristic(\"manhattan\", grid, neighbor, endPoints.end);\n        previous[`${ny}-${nx}`] = [y, x];\n        queue.enqueue(neighbor, distance, count);\n        lastdir = [ny - y, nx - x];\n      }\n    }\n    setGrid(grid);\n  }\n}","map":{"version":3,"names":["PriorityQueue","getNeighbors","heuristic","reconstructPath","gbls","colorGrid","setGrid","endPoints","grid","queue","enqueue","start","end","count","found","previous","lastdir","isEmpty","y","x","dequeue","neighbors","tempNeighbors","filter","n","i","findIndex","item","push","neighbor","ny","nx","distance"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/gbls.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\n\nexport default function gbls(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid: States[][] = [...colorGrid];\n    let queue: PriorityQueue = new PriorityQueue();\n    queue.enqueue(endPoints.start, heuristic(\"manhattan\", grid, endPoints.start, endPoints.end), 0);\n\n    let count: number = 0;\n    let found: boolean = false;\n\n    let previous: any = {};\n    let lastdir: [number, number] = [-1, -1];\n\n    while (!queue.isEmpty() && !found) {\n        let [y, x] = queue.dequeue();\n\n        if (grid[y][x] === \"red\") {\n            continue;\n        }\n\n        if (grid[y][x] !== \"orange\" && grid[y][x] !== \"blue\") {\n            grid[y][x] = \"red\";\n        }\n\n        let neighbors: [number, number][] = getNeighbors(grid, [y,x]);\n\n        if (lastdir[0] !== -1) {\n            let tempNeighbors = neighbors.filter((n) => (n[0] - y === lastdir[0]) && (n[1] - x === lastdir[1]))\n            for (const n of neighbors) {\n                let i = tempNeighbors.findIndex(item => item[0] === n[0] && item[1] === n[1]);\n                if (i === -1) {\n                    tempNeighbors.push(n);\n                }\n            }\n            neighbors = tempNeighbors;\n        }\n\n        for (const neighbor of neighbors) {\n            let [ny, nx] = neighbor;\n            if (grid[ny][nx] !== \"red\") {\n                if (grid[ny][nx] === \"blue\") {\n                    previous[`${ny}-${nx}`] = [y, x];\n                    found = true;\n                    reconstructPath(grid, previous, endPoints.end);\n                    break;\n                }\n                \n                if (grid[ny][nx] !== \"orange\") {\n                    grid[ny][nx] = \"green\";\n                }\n                \n                count++;\n                let distance: number = heuristic(\"manhattan\", grid, neighbor, endPoints.end);\n                \n                previous[`${ny}-${nx}`] = [y, x];\n                queue.enqueue(neighbor, distance, count);\n\n                lastdir = [ny - y, nx - x];\n            }\n        }\n\n        setGrid(grid);\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}