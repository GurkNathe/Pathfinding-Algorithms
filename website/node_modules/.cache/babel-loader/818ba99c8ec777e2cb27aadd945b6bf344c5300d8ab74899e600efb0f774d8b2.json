{"ast":null,"code":"import { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\nexport default function astar(colorGrid, setGrid, endPoints) {\n  let grid = [...colorGrid];\n  let count = 0;\n  let openSet = new PriorityQueue();\n  openSet.enqueue(endPoints.start, 0, count);\n  let previous = {};\n  let gscore = {};\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      gscore[`${i}-${j}`] = Infinity;\n    }\n  }\n  gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n  let countw = 0;\n  while (!openSet.isEmpty() && countw < 50) {\n    let [y, x] = openSet.dequeue();\n    if (grid[y][x] === \"blue\") {\n      reconstructPath(grid, previous, [y, x]);\n      break;\n    }\n    let temp_gscore = gscore[`${y}-${x}`] + 1;\n    for (const neighbor of getNeighbors(grid, [y, x])) {\n      let [ny, nx] = neighbor;\n      if (!openSet.contains([ny, nx])) {\n        let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n        console.log([y, x], fscore, JSON.stringify(openSet));\n        count += 1;\n        openSet.enqueue(neighbor, fscore, count);\n        if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n          grid[ny][nx] = \"green\";\n        }\n      }\n    }\n    if (grid[y][x] !== \"orange\") {\n      grid[y][x] = \"red\";\n    }\n    countw++;\n    setGrid(grid);\n  }\n}","map":{"version":3,"names":["PriorityQueue","getNeighbors","heuristic","reconstructPath","astar","colorGrid","setGrid","endPoints","grid","count","openSet","enqueue","start","previous","gscore","i","length","j","Infinity","countw","isEmpty","y","x","dequeue","temp_gscore","neighbor","ny","nx","contains","fscore","end","console","log","JSON","stringify"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/a*.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\n\nexport default function astar(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid = [...colorGrid];\n    let count: number = 0;\n    let openSet: PriorityQueue = new PriorityQueue();\n    openSet.enqueue(endPoints.start, 0, count);\n    let previous : any = {};\n\n    let gscore : any = {};\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            gscore[`${i}-${j}`] = Infinity;\n        }\n    }\n    gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n\n    let countw = 0;\n    while (!openSet.isEmpty() && countw < 50) {\n        let [y, x] = openSet.dequeue();\n        \n        if (grid[y][x] === \"blue\") {\n            reconstructPath(grid, previous, [y, x]);\n            break;\n        }\n\n        let temp_gscore = gscore[`${y}-${x}`] + 1;\n        for (const neighbor of getNeighbors(grid, [y, x])) {\n            let [ny, nx] = neighbor;\n\n            if (!openSet.contains([ny, nx])) {\n                let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n                console.log([y,x], fscore, JSON.stringify(openSet))\n                count += 1;\n                openSet.enqueue(neighbor, fscore, count);\n                if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n                    grid[ny][nx] = \"green\";\n                }\n            }\n        }\n\n        if (grid[y][x] !== \"orange\") {\n            grid[y][x] = \"red\";\n        }\n        countw++;\n        setGrid(grid);\n    }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}