{"ast":null,"code":"import { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\nexport default function astar(colorGrid, setGrid, endPoints) {\n  let grid = [...colorGrid];\n  let count = 0;\n  let openSet = new PriorityQueue();\n  openSet.enqueue(endPoints.end, 0, count);\n  let previous = {};\n  let gscore = {};\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      gscore[`${i}-${j}`] = Infinity;\n    }\n  }\n  gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n  while (!openSet.isEmpty()) {\n    let [y, x] = openSet.dequeue();\n    if (grid[y][x] === \"blue\") {\n      reconstructPath(grid, previous, [y, x]);\n      break;\n    }\n    for (const neighbor of getNeighbors(grid, [y, x])) {\n      console.table(neighbor);\n      let temp_gscore = gscore[`${y}-${x}`] + 1;\n      let [ny, nx] = neighbor;\n      if (!openSet.contains([ny, nx])) {\n        let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n        count++;\n        openSet.enqueue(neighbor, fscore, count);\n        if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n          grid[ny][nx] = \"green\";\n        }\n      }\n    }\n    if (grid[y][x] !== \"orange\") {\n      grid[y][x] = \"red\";\n    }\n    setGrid(grid);\n  }\n}","map":{"version":3,"names":["PriorityQueue","getNeighbors","heuristic","reconstructPath","astar","colorGrid","setGrid","endPoints","grid","count","openSet","enqueue","end","previous","gscore","i","length","j","Infinity","start","isEmpty","y","x","dequeue","neighbor","console","table","temp_gscore","ny","nx","contains","fscore"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/a*.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\n\nexport default function astar(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid = [...colorGrid];\n    let count: number = 0;\n    let openSet: PriorityQueue = new PriorityQueue();\n    openSet.enqueue(endPoints.end, 0, count);\n    let previous : any = {};\n\n    let gscore : any = {};\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            gscore[`${i}-${j}`] = Infinity;\n        }\n    }\n    gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n\n    while (!openSet.isEmpty()) {\n        let [y, x] = openSet.dequeue();\n        \n        if (grid[y][x] === \"blue\") {\n            reconstructPath(grid, previous, [y, x]);\n            break;\n        }\n        \n        for (const neighbor of getNeighbors(grid, [y, x])) {\n            console.table(neighbor)\n            let temp_gscore = gscore[`${y}-${x}`] + 1;\n            let [ny, nx] = neighbor;\n\n            if (!openSet.contains([ny, nx])) {\n                let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n                count++;\n                openSet.enqueue(neighbor, fscore, count);\n                if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n                    grid[ny][nx] = \"green\";\n                }\n            }\n        }\n\n        if (grid[y][x] !== \"orange\") {\n            grid[y][x] = \"red\";\n        }\n\n        setGrid(grid);\n    }\n\n}"],"mappings":"AACA,SAASA,aAAa,EAAEC,YAAY,EAAEC,SAAS,EAAEC,eAAe,QAAQ,UAAU;AAElF,eAAe,SAASC,KAAKA,CAACC,SAAqB,EAAEC,OAAyD,EAAEC,SAAoB,EAAE;EAClI,IAAIC,IAAI,GAAG,CAAC,GAAGH,SAAS,CAAC;EACzB,IAAII,KAAa,GAAG,CAAC;EACrB,IAAIC,OAAsB,GAAG,IAAIV,aAAa,CAAC,CAAC;EAChDU,OAAO,CAACC,OAAO,CAACJ,SAAS,CAACK,GAAG,EAAE,CAAC,EAAEH,KAAK,CAAC;EACxC,IAAII,QAAc,GAAG,CAAC,CAAC;EAEvB,IAAIC,MAAY,GAAG,CAAC,CAAC;EACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,IAAI,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;IAClC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,IAAI,CAAC,CAAC,CAAC,CAACQ,MAAM,EAAEC,CAAC,EAAE,EAAE;MACrCH,MAAM,CAAE,GAAEC,CAAE,IAAGE,CAAE,EAAC,CAAC,GAAGC,QAAQ;IAClC;EACJ;EACAJ,MAAM,CAAE,GAAEP,SAAS,CAACY,KAAK,CAAC,CAAC,CAAE,IAAGZ,SAAS,CAACY,KAAK,CAAC,CAAC,CAAE,EAAC,CAAC,GAAG,CAAC;EAEzD,OAAO,CAACT,OAAO,CAACU,OAAO,CAAC,CAAC,EAAE;IACvB,IAAI,CAACC,CAAC,EAAEC,CAAC,CAAC,GAAGZ,OAAO,CAACa,OAAO,CAAC,CAAC;IAE9B,IAAIf,IAAI,CAACa,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,MAAM,EAAE;MACvBnB,eAAe,CAACK,IAAI,EAAEK,QAAQ,EAAE,CAACQ,CAAC,EAAEC,CAAC,CAAC,CAAC;MACvC;IACJ;IAEA,KAAK,MAAME,QAAQ,IAAIvB,YAAY,CAACO,IAAI,EAAE,CAACa,CAAC,EAAEC,CAAC,CAAC,CAAC,EAAE;MAC/CG,OAAO,CAACC,KAAK,CAACF,QAAQ,CAAC;MACvB,IAAIG,WAAW,GAAGb,MAAM,CAAE,GAAEO,CAAE,IAAGC,CAAE,EAAC,CAAC,GAAG,CAAC;MACzC,IAAI,CAACM,EAAE,EAAEC,EAAE,CAAC,GAAGL,QAAQ;MAEvB,IAAI,CAACd,OAAO,CAACoB,QAAQ,CAAC,CAACF,EAAE,EAAEC,EAAE,CAAC,CAAC,EAAE;QAC7B,IAAIE,MAAM,GAAGJ,WAAW,GAAGzB,SAAS,CAAC,WAAW,EAAEM,IAAI,EAAEgB,QAAQ,EAAEjB,SAAS,CAACK,GAAG,CAAC,CAAC,CAAC;QAClFH,KAAK,EAAE;QACPC,OAAO,CAACC,OAAO,CAACa,QAAQ,EAAEO,MAAM,EAAEtB,KAAK,CAAC;QACxC,IAAI,EAAED,IAAI,CAACoB,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,QAAQ,IAAIrB,IAAI,CAACoB,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,MAAM,CAAC,EAAE;UACzDrB,IAAI,CAACoB,EAAE,CAAC,CAACC,EAAE,CAAC,GAAG,OAAO;QAC1B;MACJ;IACJ;IAEA,IAAIrB,IAAI,CAACa,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACzBd,IAAI,CAACa,CAAC,CAAC,CAACC,CAAC,CAAC,GAAG,KAAK;IACtB;IAEAhB,OAAO,CAACE,IAAI,CAAC;EACjB;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}