{"ast":null,"code":"import { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\nexport default function astar(colorGrid, setGrid, endPoints) {\n  let grid = [...colorGrid];\n  let count = 0;\n  let openSet = new PriorityQueue();\n  openSet.enqueue(endPoints.start, 0, count);\n  let previous = {};\n  let gscore = {};\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      gscore[`${i}-${j}`] = Infinity;\n    }\n  }\n  gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n  while (!openSet.isEmpty()) {\n    let [y, x] = openSet.dequeue();\n    if (grid[y][x] === \"blue\") {\n      reconstructPath(grid, previous, [y, x]);\n      break;\n    }\n    let temp_gscore = gscore[`${y}-${x}`] + 1;\n    for (const neighbor of getNeighbors(grid, [y, x])) {\n      let [ny, nx] = neighbor;\n      if (temp_gscore < gscore[`${ny}-${nx}`]) {\n        previous[`${ny}-${nx}`] = [y, x];\n        gscore[`${ny}-${nx}`] = temp_gscore;\n        if (!openSet.contains([ny, nx])) {\n          let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n          count++;\n          openSet.enqueue(neighbor, fscore, count);\n          if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n            grid[ny][nx] = \"green\";\n          }\n        }\n      }\n    }\n    if (grid[y][x] !== \"orange\") {\n      grid[y][x] = \"red\";\n    }\n    setGrid(grid);\n  }\n}","map":{"version":3,"names":["PriorityQueue","getNeighbors","heuristic","reconstructPath","astar","colorGrid","setGrid","endPoints","grid","count","openSet","enqueue","start","previous","gscore","i","length","j","Infinity","isEmpty","y","x","dequeue","temp_gscore","neighbor","ny","nx","contains","fscore","end"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/a*.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\n\nexport default function astar(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid = [...colorGrid];\n    let count: number = 0;\n    let openSet: PriorityQueue = new PriorityQueue();\n    openSet.enqueue(endPoints.start, 0, count);\n    let previous : any = {};\n\n    let gscore : any = {};\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            gscore[`${i}-${j}`] = Infinity;\n        }\n    }\n    gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n\n    while (!openSet.isEmpty()) {\n        let [y, x] = openSet.dequeue();\n        \n        if (grid[y][x] === \"blue\") {\n            reconstructPath(grid, previous, [y, x]);\n            break;\n        }\n\n        let temp_gscore = gscore[`${y}-${x}`] + 1;\n        for (const neighbor of getNeighbors(grid, [y, x])) {\n            let [ny, nx] = neighbor;\n\n            if (temp_gscore < gscore[`${ny}-${nx}`]) {\n                previous[`${ny}-${nx}`] = [y, x];\n                gscore[`${ny}-${nx}`] = temp_gscore;\n\n                if (!openSet.contains([ny, nx])) {\n                    let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n                    count++;\n                    openSet.enqueue(neighbor, fscore, count);\n                    if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n                        grid[ny][nx] = \"green\";\n                    }\n                }\n            }\n\n        }\n\n        if (grid[y][x] !== \"orange\") {\n            grid[y][x] = \"red\";\n        }\n\n        setGrid(grid);\n    }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}