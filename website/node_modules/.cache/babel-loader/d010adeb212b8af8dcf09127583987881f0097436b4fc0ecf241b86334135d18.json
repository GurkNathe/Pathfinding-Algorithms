{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/krug/Coding/Python/Pathfinding-Algorithms/website/node_modules/.pnpm/@babel+runtime@7.22.5/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _slicedToArray from\"/home/krug/Coding/Python/Pathfinding-Algorithms/website/node_modules/.pnpm/@babel+runtime@7.22.5/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _toConsumableArray from\"/home/krug/Coding/Python/Pathfinding-Algorithms/website/node_modules/.pnpm/@babel+runtime@7.22.5/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import{PriorityQueue,getNeighbors,heuristic,reconstructPath}from\"./helper\";export default function astar(colorGrid,setGrid,endPoints){var grid=_toConsumableArray(colorGrid);var count=0;var openSet=new PriorityQueue();openSet.enqueue(endPoints.start,0,count);var previous={};var gscore={};for(var i=0;i<grid.length;i++){for(var j=0;j<grid[0].length;j++){gscore[\"\".concat(i,\"-\").concat(j)]=Infinity;}}gscore[\"\".concat(endPoints.start[0],\"-\").concat(endPoints.start[1])]=0;while(!openSet.isEmpty()){var _openSet$dequeue=openSet.dequeue(),_openSet$dequeue2=_slicedToArray(_openSet$dequeue,2),y=_openSet$dequeue2[0],x=_openSet$dequeue2[1];if(grid[y][x]===\"blue\"){reconstructPath(grid,previous,[y,x]);break;}var temp_gscore=gscore[\"\".concat(y,\"-\").concat(x)]+1;var _iterator=_createForOfIteratorHelper(getNeighbors(grid,[y,x])),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var neighbor=_step.value;var _neighbor=_slicedToArray(neighbor,2),ny=_neighbor[0],nx=_neighbor[1];if(temp_gscore<gscore[\"\".concat(ny,\"-\").concat(nx)]){previous[\"\".concat(ny,\"-\").concat(nx)]=[y,x];gscore[\"\".concat(ny,\"-\").concat(nx)]=temp_gscore;if(!openSet.contains([ny,nx])){var fscore=temp_gscore+heuristic(\"manhattan\",grid,neighbor,endPoints.end);// + heuristic\ncount++;openSet.enqueue(neighbor,fscore,count);if(!(grid[ny][nx]===\"orange\"||grid[ny][nx]===\"blue\")){grid[ny][nx]=\"green\";}}}}}catch(err){_iterator.e(err);}finally{_iterator.f();}if(grid[y][x]!==\"orange\"){grid[y][x]=\"red\";}setGrid(grid);}}","map":{"version":3,"names":["PriorityQueue","getNeighbors","heuristic","reconstructPath","astar","colorGrid","setGrid","endPoints","grid","_toConsumableArray","count","openSet","enqueue","start","previous","gscore","i","length","j","concat","Infinity","isEmpty","_openSet$dequeue","dequeue","_openSet$dequeue2","_slicedToArray","y","x","temp_gscore","_iterator","_createForOfIteratorHelper","_step","s","n","done","neighbor","value","_neighbor","ny","nx","contains","fscore","end","err","e","f"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/a*.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\n\nexport default function astar(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid = [...colorGrid];\n    let count: number = 0;\n    let openSet: PriorityQueue = new PriorityQueue();\n    openSet.enqueue(endPoints.start, 0, count);\n    let previous : any = {};\n\n    let gscore : any = {};\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            gscore[`${i}-${j}`] = Infinity;\n        }\n    }\n    gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n\n    while (!openSet.isEmpty()) {\n        let [y, x] = openSet.dequeue();\n        \n        if (grid[y][x] === \"blue\") {\n            reconstructPath(grid, previous, [y, x]);\n            break;\n        }\n\n        let temp_gscore = gscore[`${y}-${x}`] + 1;\n        for (const neighbor of getNeighbors(grid, [y, x])) {\n            let [ny, nx] = neighbor;\n\n            if (temp_gscore < gscore[`${ny}-${nx}`]) {\n                previous[`${ny}-${nx}`] = [y, x];\n                gscore[`${ny}-${nx}`] = temp_gscore;\n\n                if (!openSet.contains([ny, nx])) {\n                    let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n                    count++;\n                    openSet.enqueue(neighbor, fscore, count);\n                    if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n                        grid[ny][nx] = \"green\";\n                    }\n                }\n            }\n\n        }\n\n        if (grid[y][x] !== \"orange\") {\n            grid[y][x] = \"red\";\n        }\n\n        setGrid(grid);\n    }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}