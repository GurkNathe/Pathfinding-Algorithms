{"ast":null,"code":"export function getNeighbors(grid, pos) {\n  let [i, j] = pos;\n  let neighbors = [];\n  if (i - 1 >= 0 && grid[i - 1][j] !== \"black\") {\n    neighbors.push([i - 1, j]);\n  }\n  if (j - 1 >= 0 && grid[i][j - 1] !== \"black\") {\n    neighbors.push([i, j - 1]);\n  }\n  if (i + 1 < grid.length && grid[i + 1][j] !== \"black\") {\n    neighbors.push([i + 1, j]);\n  }\n  if (j + 1 < grid[0].length && grid[i][j + 1] !== \"black\") {\n    neighbors.push([i, j + 1]);\n  }\n  return neighbors;\n}\nexport function reconstructPath(grid, path, current) {\n  while (path.hasOwnProperty(`${current[0]}-${current[1]}`)) {\n    if (grid[current[0]][current[1]] !== \"orange\") {\n      current = path[`${current[0]}-${current[1]}`];\n      if (grid[current[0]][current[1]] !== \"orange\") {\n        grid[current[0]][current[1]] = \"purple\";\n      }\n    } else {\n      break;\n    }\n  }\n}\nfunction manhattan(grid, node1, node2) {\n  let [y1, x1] = node1;\n  let [y2, x2] = node2;\n  return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n}\nexport function heuristic(type, grid, start, end) {\n  switch (type) {\n    case \"manhattan\":\n      return manhattan(grid, start, end);\n    default:\n      return manhattan(grid, start, end);\n  }\n}\n\n// User defined class to store elements and their priorities\nclass QElement {\n  constructor(element, priority, count) {\n    this.element = void 0;\n    this.priority = void 0;\n    this.count = void 0;\n    this.element = element;\n    this.priority = priority;\n    this.count = count;\n  }\n}\n\n// PriorityQueue class\nexport class PriorityQueue {\n  constructor() {\n    this.items = void 0;\n    this.items = [];\n  }\n  size() {\n    return this.items.length;\n  }\n  contains(element) {\n    return this.items.some(item => {\n      return JSON.stringify(item.element) === JSON.stringify(element);\n    });\n  }\n  enqueue(element, priority, count) {\n    const qElement = new QElement(element, priority, count);\n    let contain = false;\n\n    // Iterate through the entire array to add the element at the correct position based on priority\n    for (let i = 0; i < this.items.length; i++) {\n      if (this.items[i].priority > qElement.priority) {\n        this.items.splice(i, 0, qElement);\n        contain = true;\n        break;\n      } else if (this.items[i].priority === qElement.priority) {\n        if (this.items[i].count < qElement.count) {\n          this.items.splice(i + 1, 0, qElement);\n        } else {\n          this.items.splice(i, 0, qElement);\n        }\n        contain = true;\n        break;\n      }\n    }\n\n    // If the element has the highest priority, add it to the end of the array\n    if (!contain) {\n      this.items.push(qElement);\n    }\n  }\n  dequeue() {\n    // If the priority queue is empty, return \"No elements in Queue\"\n    if (this.isEmpty()) {\n      return;\n    }\n\n    // Remove and return the first element from the array, as it has the highest priority\n    return this.items.shift().element;\n  }\n  isEmpty() {\n    // Return true if the priority queue is empty\n    return this.items.length === 0;\n  }\n}","map":{"version":3,"names":["getNeighbors","grid","pos","i","j","neighbors","push","length","reconstructPath","path","current","hasOwnProperty","manhattan","node1","node2","y1","x1","y2","x2","Math","abs","heuristic","type","start","end","QElement","constructor","element","priority","count","PriorityQueue","items","size","contains","some","item","JSON","stringify","enqueue","qElement","contain","splice","dequeue","isEmpty","shift"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/helper.ts"],"sourcesContent":["import { States } from \"../components/Panel\";\n\nexport function getNeighbors(grid: States[][], pos: [number, number]) {\n    let [i, j] = pos;\n\n    let neighbors : [number, number][] = [];\n\n    if (i - 1 >= 0 && grid[i - 1][j] !== \"black\") {\n        neighbors.push([i - 1, j]);\n    }\n    if (j - 1 >= 0 && grid[i][j - 1] !== \"black\") {\n        neighbors.push([i, j - 1]);\n    }\n    if (i + 1 < grid.length && grid[i + 1][j] !== \"black\") {\n        neighbors.push([i + 1, j]);\n    }\n    if (j + 1 < grid[0].length && grid[i][j + 1] !== \"black\") {\n        neighbors.push([i, j + 1]);\n    }\n\n    return neighbors;\n}\n\nexport function reconstructPath(grid: States[][], path: any, current: [number, number])  {\n    while (path.hasOwnProperty(`${current[0]}-${current[1]}`)) {\n        if (grid[current[0]][current[1]] !== \"orange\") {\n            current = path[`${current[0]}-${current[1]}`]\n            if (grid[current[0]][current[1]] !== \"orange\") {\n                grid[current[0]][current[1]] = \"purple\";\n            }\n        } else {\n            break;\n        }\n    }\n}\n\nfunction manhattan(grid: States[][], node1: [number, number], node2: [number, number]) {\n    let [y1, x1] = node1;\n    let [y2, x2] = node2;\n\n    return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n}\n\nexport function heuristic(type: string, grid: States[][], start: [number, number], end: [number, number]) {\n    switch(type) {\n        case \"manhattan\":\n            return manhattan(grid, start, end);\n        default:\n            return manhattan(grid, start, end);\n    }\n}\n\n// User defined class to store elements and their priorities\nclass QElement {\n    element: any;\n    priority: number;\n    count: number;\n\n    constructor(element : any, priority: number, count: number) {\n        this.element = element;\n        this.priority = priority;\n        this.count = count;\n    }\n}\n\n// PriorityQueue class\nexport class PriorityQueue {\n    items: QElement[];\n\n    constructor() {\n        this.items = [];\n    }\n\n    size() {\n        return this.items.length;\n    }\n\n    contains(element: [number, number]) {\n        return this.items.some((item) => {\n            return JSON.stringify(item.element) === JSON.stringify(element);\n        });\n    }\n\n    enqueue(element: [number, number], priority: number, count: number) {\n        const qElement = new QElement(element, priority, count);\n        let contain = false;\n\n        // Iterate through the entire array to add the element at the correct position based on priority\n        for (let i = 0; i < this.items.length; i++) {\n            if (this.items[i].priority > qElement.priority) {\n                this.items.splice(i, 0, qElement);\n                contain = true;\n                break;\n            } else if (this.items[i].priority === qElement.priority) {\n                if (this.items[i].count < qElement.count) {\n                    this.items.splice(i + 1, 0, qElement);\n                } else {\n                    this.items.splice(i, 0, qElement);\n                }\n                contain = true;\n                break;\n            }\n        }\n\n        // If the element has the highest priority, add it to the end of the array\n        if (!contain) {\n            this.items.push(qElement);\n        }\n    }\n\n    dequeue() {\n        // If the priority queue is empty, return \"No elements in Queue\"\n        if (this.isEmpty()) {\n            return;\n        }\n        \n        // Remove and return the first element from the array, as it has the highest priority\n        return this.items.shift()!.element;\n    }\n\n    isEmpty() {\n        // Return true if the priority queue is empty\n        return this.items.length === 0;\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}