{"ast":null,"code":"import { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\nexport default function astar(colorGrid, setGrid, endPoints) {\n  let grid = [...colorGrid];\n  let count = 0;\n  let openSet = new PriorityQueue();\n  openSet.enqueue(endPoints.start, 0, count);\n  let previous = {};\n  let gscore = {};\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      gscore[`${i}-${j}`] = Infinity;\n    }\n  }\n  gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n  while (!openSet.isEmpty()) {\n    let [y, x] = openSet.dequeue();\n    if (grid[y][x] === \"blue\") {\n      reconstructPath(grid, previous, [y, x]);\n      break;\n    }\n    console.table(gscore);\n    for (const neighbor of getNeighbors(grid, [y, x])) {\n      let temp_gscore = gscore[`${y}-${x}`] + 1;\n      let [ny, nx] = neighbor;\n      if (!openSet.contains([ny, nx])) {\n        let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n        count++;\n        openSet.enqueue(neighbor, fscore, count);\n        if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n          grid[ny][nx] = \"green\";\n        }\n      }\n    }\n    if (grid[y][x] !== \"orange\") {\n      grid[y][x] = \"red\";\n    }\n    setGrid(grid);\n  }\n}","map":{"version":3,"names":["PriorityQueue","getNeighbors","heuristic","reconstructPath","astar","colorGrid","setGrid","endPoints","grid","count","openSet","enqueue","start","previous","gscore","i","length","j","Infinity","isEmpty","y","x","dequeue","console","table","neighbor","temp_gscore","ny","nx","contains","fscore","end"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/a*.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\n\nexport default function astar(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid = [...colorGrid];\n    let count: number = 0;\n    let openSet: PriorityQueue = new PriorityQueue();\n    openSet.enqueue(endPoints.start, 0, count);\n    let previous : any = {};\n\n    let gscore : any = {};\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            gscore[`${i}-${j}`] = Infinity;\n        }\n    }\n    gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n\n    while (!openSet.isEmpty()) {\n        let [y, x] = openSet.dequeue();\n\n        if (grid[y][x] === \"blue\") {\n            reconstructPath(grid, previous, [y, x]);\n            break;\n        }\n        console.table(gscore)\n        for (const neighbor of getNeighbors(grid, [y, x])) {\n            let temp_gscore = gscore[`${y}-${x}`] + 1;\n            let [ny, nx] = neighbor;\n\n            if (!openSet.contains([ny, nx])) {\n                let fscore = temp_gscore + heuristic(\"manhattan\", grid, neighbor, endPoints.end); // + heuristic\n                count++;\n                openSet.enqueue(neighbor, fscore, count);\n                if (!(grid[ny][nx] === \"orange\" || grid[ny][nx] === \"blue\")) {\n                    grid[ny][nx] = \"green\";\n                }\n            }\n        }\n\n        if (grid[y][x] !== \"orange\") {\n            grid[y][x] = \"red\";\n        }\n\n        setGrid(grid);\n    }\n\n}"],"mappings":"AACA,SAASA,aAAa,EAAEC,YAAY,EAAEC,SAAS,EAAEC,eAAe,QAAQ,UAAU;AAElF,eAAe,SAASC,KAAKA,CAACC,SAAqB,EAAEC,OAAyD,EAAEC,SAAoB,EAAE;EAClI,IAAIC,IAAI,GAAG,CAAC,GAAGH,SAAS,CAAC;EACzB,IAAII,KAAa,GAAG,CAAC;EACrB,IAAIC,OAAsB,GAAG,IAAIV,aAAa,CAAC,CAAC;EAChDU,OAAO,CAACC,OAAO,CAACJ,SAAS,CAACK,KAAK,EAAE,CAAC,EAAEH,KAAK,CAAC;EAC1C,IAAII,QAAc,GAAG,CAAC,CAAC;EAEvB,IAAIC,MAAY,GAAG,CAAC,CAAC;EACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,IAAI,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;IAClC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,IAAI,CAAC,CAAC,CAAC,CAACQ,MAAM,EAAEC,CAAC,EAAE,EAAE;MACrCH,MAAM,CAAE,GAAEC,CAAE,IAAGE,CAAE,EAAC,CAAC,GAAGC,QAAQ;IAClC;EACJ;EACAJ,MAAM,CAAE,GAAEP,SAAS,CAACK,KAAK,CAAC,CAAC,CAAE,IAAGL,SAAS,CAACK,KAAK,CAAC,CAAC,CAAE,EAAC,CAAC,GAAG,CAAC;EAEzD,OAAO,CAACF,OAAO,CAACS,OAAO,CAAC,CAAC,EAAE;IACvB,IAAI,CAACC,CAAC,EAAEC,CAAC,CAAC,GAAGX,OAAO,CAACY,OAAO,CAAC,CAAC;IAE9B,IAAId,IAAI,CAACY,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,MAAM,EAAE;MACvBlB,eAAe,CAACK,IAAI,EAAEK,QAAQ,EAAE,CAACO,CAAC,EAAEC,CAAC,CAAC,CAAC;MACvC;IACJ;IACAE,OAAO,CAACC,KAAK,CAACV,MAAM,CAAC;IACrB,KAAK,MAAMW,QAAQ,IAAIxB,YAAY,CAACO,IAAI,EAAE,CAACY,CAAC,EAAEC,CAAC,CAAC,CAAC,EAAE;MAC/C,IAAIK,WAAW,GAAGZ,MAAM,CAAE,GAAEM,CAAE,IAAGC,CAAE,EAAC,CAAC,GAAG,CAAC;MACzC,IAAI,CAACM,EAAE,EAAEC,EAAE,CAAC,GAAGH,QAAQ;MAEvB,IAAI,CAACf,OAAO,CAACmB,QAAQ,CAAC,CAACF,EAAE,EAAEC,EAAE,CAAC,CAAC,EAAE;QAC7B,IAAIE,MAAM,GAAGJ,WAAW,GAAGxB,SAAS,CAAC,WAAW,EAAEM,IAAI,EAAEiB,QAAQ,EAAElB,SAAS,CAACwB,GAAG,CAAC,CAAC,CAAC;QAClFtB,KAAK,EAAE;QACPC,OAAO,CAACC,OAAO,CAACc,QAAQ,EAAEK,MAAM,EAAErB,KAAK,CAAC;QACxC,IAAI,EAAED,IAAI,CAACmB,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,QAAQ,IAAIpB,IAAI,CAACmB,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,MAAM,CAAC,EAAE;UACzDpB,IAAI,CAACmB,EAAE,CAAC,CAACC,EAAE,CAAC,GAAG,OAAO;QAC1B;MACJ;IACJ;IAEA,IAAIpB,IAAI,CAACY,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACzBb,IAAI,CAACY,CAAC,CAAC,CAACC,CAAC,CAAC,GAAG,KAAK;IACtB;IAEAf,OAAO,CAACE,IAAI,CAAC;EACjB;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}