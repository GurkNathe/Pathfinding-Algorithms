{"ast":null,"code":"import { PriorityQueue, getNeighbors, reconstructPath } from \"./helper\";\nexport default function dijkstra(colorGrid, setGrid, endPoints) {\n  let grid = [...colorGrid];\n  let queue = new PriorityQueue();\n  let gscore = {};\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      gscore[`${i}-${j}`] = Infinity;\n    }\n  }\n  gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n  let previous = {};\n  queue.enqueue(endPoints.start, 0, 0);\n  let count = 0;\n  while (!queue.isEmpty()) {\n    let [y, x] = queue.dequeue();\n    if (grid[y][x] === \"blue\") {\n      reconstructPath(grid, previous, [y, x]);\n      break;\n    }\n    if (grid[y][x] !== \"orange\") {\n      grid[y][x] = \"red\";\n    }\n    for (const neighbor of getNeighbors(grid, [y, x])) {\n      let [ny, nx] = neighbor;\n      if (grid[ny][nx] !== \"red\") {\n        let temp_gscore = gscore[`${y}-${x}`] + 1;\n        if (temp_gscore < gscore[`${ny}-${nx}`]) {\n          gscore[`${ny}-${nx}`] = temp_gscore;\n          previous[`${ny}-${nx}`] = [y, x];\n          count++;\n          queue.enqueue(neighbor, temp_gscore, count);\n          if (grid[ny][nx] !== \"orange\" && grid[ny][nx] !== \"blue\") {\n            grid[ny][nx] = \"green\";\n          }\n        }\n      }\n    }\n    setGrid(grid);\n  }\n}","map":{"version":3,"names":["PriorityQueue","getNeighbors","reconstructPath","dijkstra","colorGrid","setGrid","endPoints","grid","queue","gscore","i","length","j","Infinity","start","previous","enqueue","count","isEmpty","y","x","dequeue","neighbor","ny","nx","temp_gscore"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/dijkstra.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\n\nexport default function dijkstra(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid: States[][] = [...colorGrid];\n    let queue: PriorityQueue = new PriorityQueue();\n\n    let gscore: any = {};\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            gscore[`${i}-${j}`] = Infinity;\n        }\n    }\n    gscore[`${endPoints.start[0]}-${endPoints.start[1]}`] = 0;\n\n    let previous: any = {};\n\n    queue.enqueue(endPoints.start, 0, 0);\n\n    let count: number = 0\n\n    while(!queue.isEmpty()) {\n        let [y, x] = queue.dequeue();\n\n        if (grid[y][x] === \"blue\") {\n            reconstructPath(grid, previous, [y, x]);\n            break;\n        }\n\n        if (grid[y][x] !== \"orange\") {\n            grid[y][x] = \"red\";\n        }\n\n        for (const neighbor of getNeighbors(grid, [y, x])) {\n            let [ny, nx] = neighbor;\n            if (grid[ny][nx] !== \"red\") {\n                let temp_gscore = gscore[`${y}-${x}`] + 1;\n                \n                if (temp_gscore < gscore[`${ny}-${nx}`]) {\n                    gscore[`${ny}-${nx}`] = temp_gscore;\n                    previous[`${ny}-${nx}`] = [y, x];\n\n                    count++;\n                    queue.enqueue(neighbor, temp_gscore, count);\n\n                    if (grid[ny][nx] !== \"orange\" && grid[ny][nx] !== \"blue\") {\n                        grid[ny][nx] = \"green\";\n                    }\n                }\n            }\n        }\n\n        setGrid(grid);\n    }\n}"],"mappings":"AACA,SAASA,aAAa,EAAEC,YAAY,EAAaC,eAAe,QAAQ,UAAU;AAElF,eAAe,SAASC,QAAQA,CAACC,SAAqB,EAAEC,OAAyD,EAAEC,SAAoB,EAAE;EACrI,IAAIC,IAAgB,GAAG,CAAC,GAAGH,SAAS,CAAC;EACrC,IAAII,KAAoB,GAAG,IAAIR,aAAa,CAAC,CAAC;EAE9C,IAAIS,MAAW,GAAG,CAAC,CAAC;EACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IAClC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAAC,CAAC,CAAC,CAACI,MAAM,EAAEC,CAAC,EAAE,EAAE;MACrCH,MAAM,CAAE,GAAEC,CAAE,IAAGE,CAAE,EAAC,CAAC,GAAGC,QAAQ;IAClC;EACJ;EACAJ,MAAM,CAAE,GAAEH,SAAS,CAACQ,KAAK,CAAC,CAAC,CAAE,IAAGR,SAAS,CAACQ,KAAK,CAAC,CAAC,CAAE,EAAC,CAAC,GAAG,CAAC;EAEzD,IAAIC,QAAa,GAAG,CAAC,CAAC;EAEtBP,KAAK,CAACQ,OAAO,CAACV,SAAS,CAACQ,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;EAEpC,IAAIG,KAAa,GAAG,CAAC;EAErB,OAAM,CAACT,KAAK,CAACU,OAAO,CAAC,CAAC,EAAE;IACpB,IAAI,CAACC,CAAC,EAAEC,CAAC,CAAC,GAAGZ,KAAK,CAACa,OAAO,CAAC,CAAC;IAE5B,IAAId,IAAI,CAACY,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,MAAM,EAAE;MACvBlB,eAAe,CAACK,IAAI,EAAEQ,QAAQ,EAAE,CAACI,CAAC,EAAEC,CAAC,CAAC,CAAC;MACvC;IACJ;IAEA,IAAIb,IAAI,CAACY,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACzBb,IAAI,CAACY,CAAC,CAAC,CAACC,CAAC,CAAC,GAAG,KAAK;IACtB;IAEA,KAAK,MAAME,QAAQ,IAAIrB,YAAY,CAACM,IAAI,EAAE,CAACY,CAAC,EAAEC,CAAC,CAAC,CAAC,EAAE;MAC/C,IAAI,CAACG,EAAE,EAAEC,EAAE,CAAC,GAAGF,QAAQ;MACvB,IAAIf,IAAI,CAACgB,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,KAAK,EAAE;QACxB,IAAIC,WAAW,GAAGhB,MAAM,CAAE,GAAEU,CAAE,IAAGC,CAAE,EAAC,CAAC,GAAG,CAAC;QAEzC,IAAIK,WAAW,GAAGhB,MAAM,CAAE,GAAEc,EAAG,IAAGC,EAAG,EAAC,CAAC,EAAE;UACrCf,MAAM,CAAE,GAAEc,EAAG,IAAGC,EAAG,EAAC,CAAC,GAAGC,WAAW;UACnCV,QAAQ,CAAE,GAAEQ,EAAG,IAAGC,EAAG,EAAC,CAAC,GAAG,CAACL,CAAC,EAAEC,CAAC,CAAC;UAEhCH,KAAK,EAAE;UACPT,KAAK,CAACQ,OAAO,CAACM,QAAQ,EAAEG,WAAW,EAAER,KAAK,CAAC;UAE3C,IAAIV,IAAI,CAACgB,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,QAAQ,IAAIjB,IAAI,CAACgB,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,MAAM,EAAE;YACtDjB,IAAI,CAACgB,EAAE,CAAC,CAACC,EAAE,CAAC,GAAG,OAAO;UAC1B;QACJ;MACJ;IACJ;IAEAnB,OAAO,CAACE,IAAI,CAAC;EACjB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}