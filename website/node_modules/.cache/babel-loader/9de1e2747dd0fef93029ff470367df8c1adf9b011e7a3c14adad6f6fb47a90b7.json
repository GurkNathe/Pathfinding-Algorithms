{"ast":null,"code":"import { getNeighbors, reconstructPath } from \"./helper\";\nexport default function dfs(colorGrid, setGrid, endPoints) {\n  let grid = [...colorGrid];\n  let stack = [];\n  let previous = {};\n  let found = false;\n  while (stack.length > 0 && !found) {\n    let [y, x] = stack.pop();\n    if (grid[y][x] === \"red\") {\n      continue;\n    }\n    grid[y][x] = \"red\";\n    for (const neighbor of getNeighbors(grid, [y, x])) {\n      let [ny, nx] = neighbor;\n      if (grid[ny][nx] !== \"red\") {\n        if (grid[ny][nx] === \"blue\") {\n          previous[`${ny}-${nx}`] = [y, x];\n          found = true;\n          reconstructPath(grid, previous, endPoints.end);\n          break;\n        } else {\n          previous[`${ny}-${nx}`] = [y, x];\n          stack.push(neighbor);\n          if (grid[ny][nx] !== \"orange\") {\n            grid[ny][nx] === \"green\";\n          }\n        }\n      }\n    }\n    setGrid(grid);\n  }\n}","map":{"version":3,"names":["getNeighbors","reconstructPath","dfs","colorGrid","setGrid","endPoints","grid","stack","previous","found","length","y","x","pop","neighbor","ny","nx","end","push"],"sources":["/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/dfs.ts"],"sourcesContent":["import { Interests, States } from \"../components/Panel\"\nimport { getNeighbors, reconstructPath } from \"./helper\";\n\n\nexport default function dfs(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid: States[][] = [...colorGrid];\n    let stack: [number, number][] = [];\n\n    let previous : any = {};\n\n    let found: boolean = false;\n\n    while (stack.length > 0 && !found) {\n        let [y, x] = stack.pop()!;\n\n        if (grid[y][x] === \"red\") {\n            continue;\n        }\n\n        grid[y][x] = \"red\";\n\n        for (const neighbor of getNeighbors(grid, [y, x])) {\n            let [ny, nx] = neighbor;\n            if (grid[ny][nx] !== \"red\") {\n                if (grid[ny][nx] === \"blue\") {\n                    previous[`${ny}-${nx}`] = [y,x];\n                    found = true;\n                    reconstructPath(grid, previous, endPoints.end);\n                    break;\n                } else {\n                    previous[`${ny}-${nx}`] = [y,x];\n                    stack.push(neighbor);\n\n                    if (grid[ny][nx] !== \"orange\") {\n                        grid[ny][nx] === \"green\"\n                    }\n                }\n            }\n        }\n        setGrid(grid)\n    }\n}"],"mappings":"AACA,SAASA,YAAY,EAAEC,eAAe,QAAQ,UAAU;AAGxD,eAAe,SAASC,GAAGA,CAACC,SAAqB,EAAEC,OAAyD,EAAEC,SAAoB,EAAE;EAChI,IAAIC,IAAgB,GAAG,CAAC,GAAGH,SAAS,CAAC;EACrC,IAAII,KAAyB,GAAG,EAAE;EAElC,IAAIC,QAAc,GAAG,CAAC,CAAC;EAEvB,IAAIC,KAAc,GAAG,KAAK;EAE1B,OAAOF,KAAK,CAACG,MAAM,GAAG,CAAC,IAAI,CAACD,KAAK,EAAE;IAC/B,IAAI,CAACE,CAAC,EAAEC,CAAC,CAAC,GAAGL,KAAK,CAACM,GAAG,CAAC,CAAE;IAEzB,IAAIP,IAAI,CAACK,CAAC,CAAC,CAACC,CAAC,CAAC,KAAK,KAAK,EAAE;MACtB;IACJ;IAEAN,IAAI,CAACK,CAAC,CAAC,CAACC,CAAC,CAAC,GAAG,KAAK;IAElB,KAAK,MAAME,QAAQ,IAAId,YAAY,CAACM,IAAI,EAAE,CAACK,CAAC,EAAEC,CAAC,CAAC,CAAC,EAAE;MAC/C,IAAI,CAACG,EAAE,EAAEC,EAAE,CAAC,GAAGF,QAAQ;MACvB,IAAIR,IAAI,CAACS,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,KAAK,EAAE;QACxB,IAAIV,IAAI,CAACS,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,MAAM,EAAE;UACzBR,QAAQ,CAAE,GAAEO,EAAG,IAAGC,EAAG,EAAC,CAAC,GAAG,CAACL,CAAC,EAACC,CAAC,CAAC;UAC/BH,KAAK,GAAG,IAAI;UACZR,eAAe,CAACK,IAAI,EAAEE,QAAQ,EAAEH,SAAS,CAACY,GAAG,CAAC;UAC9C;QACJ,CAAC,MAAM;UACHT,QAAQ,CAAE,GAAEO,EAAG,IAAGC,EAAG,EAAC,CAAC,GAAG,CAACL,CAAC,EAACC,CAAC,CAAC;UAC/BL,KAAK,CAACW,IAAI,CAACJ,QAAQ,CAAC;UAEpB,IAAIR,IAAI,CAACS,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,QAAQ,EAAE;YAC3BV,IAAI,CAACS,EAAE,CAAC,CAACC,EAAE,CAAC,KAAK,OAAO;UAC5B;QACJ;MACJ;IACJ;IACAZ,OAAO,CAACE,IAAI,CAAC;EACjB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}