[{"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/index.tsx":"1","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/App.tsx":"2","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/components/Panel.tsx":"3","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/bfs.ts":"4","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/helper.ts":"5","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/a*.ts":"6","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/dfs.ts":"7","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/beamsearch.ts":"8","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/gbls.ts":"9","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/dijkstra.ts":"10"},{"size":287,"mtime":1686962386934,"results":"11","hashOfConfig":"12"},{"size":141,"mtime":1686963918568,"results":"13","hashOfConfig":"12"},{"size":15144,"mtime":1687402984433,"results":"14","hashOfConfig":"12"},{"size":1381,"mtime":1687377711846,"results":"15","hashOfConfig":"12"},{"size":3237,"mtime":1687403176802,"results":"16","hashOfConfig":"12"},{"size":1793,"mtime":1687402475304,"results":"17","hashOfConfig":"12"},{"size":1348,"mtime":1687393837344,"results":"18","hashOfConfig":"12"},{"size":1465,"mtime":1687395563082,"results":"19","hashOfConfig":"12"},{"size":2235,"mtime":1687404013863,"results":"20","hashOfConfig":"12"},{"size":1685,"mtime":1687403317048,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},"70vsjr",{"filePath":"26","messages":"27","suppressedMessages":"28","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"29","messages":"30","suppressedMessages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","suppressedMessages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","suppressedMessages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","suppressedMessages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","suppressedMessages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50"},{"filePath":"51","messages":"52","suppressedMessages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/index.tsx",[],[],[],"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/App.tsx",[],[],"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/components/Panel.tsx",[],[],"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/bfs.ts",[],[],"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/helper.ts",[],[],"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/a*.ts",[],[],"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/dfs.ts",[],[],"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/beamsearch.ts",[],[],"/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/gbls.ts",["54"],[],"import { Interests, States } from \"../components/Panel\"\nimport { PriorityQueue, getNeighbors, heuristic, reconstructPath } from \"./helper\";\n\nexport default function gbls(colorGrid: States[][], setGrid: React.Dispatch<React.SetStateAction<States[][]>>, endPoints: Interests) {\n    let grid: States[][] = [...colorGrid];\n    let queue: PriorityQueue = new PriorityQueue();\n    queue.enqueue(endPoints.start, heuristic(\"manhattan\", grid, endPoints.start, endPoints.end), 0);\n\n    let count: number = 0;\n    let found: boolean = false;\n\n    let previous: any = {};\n    let lastdir: [number, number] = [-1, -1];\n\n    while (!queue.isEmpty() && !found) {\n        let [y, x] = queue.dequeue();\n\n        if (grid[y][x] === \"red\") {\n            continue;\n        }\n\n        if (grid[y][x] !== \"orange\" && grid[y][x] !== \"blue\") {\n            grid[y][x] = \"red\";\n        }\n\n        let neighbors: [number, number][] = getNeighbors(grid, [y,x]);\n\n        if (lastdir[0] !== -1) {\n            let tempNeighbors = neighbors.filter((n) => (n[0] - y === lastdir[0]) && (n[1] - x === lastdir[1]));\n            for (const n of neighbors) {\n                let i = tempNeighbors.findIndex(item => item[0] === n[0] && item[1] === n[1]);\n                if (i === -1) {\n                    tempNeighbors.push(n);\n                }\n            }\n            neighbors = tempNeighbors;\n        }\n\n        for (const neighbor of neighbors) {\n            let [ny, nx] = neighbor;\n            if (grid[ny][nx] !== \"red\") {\n                if (grid[ny][nx] === \"blue\") {\n                    previous[`${ny}-${nx}`] = [y, x];\n                    found = true;\n                    reconstructPath(grid, previous, endPoints.end);\n                    break;\n                }\n                \n                if (grid[ny][nx] !== \"orange\") {\n                    grid[ny][nx] = \"green\";\n                }\n                \n                count++;\n                let distance: number = heuristic(\"manhattan\", grid, neighbor, endPoints.end);\n                \n                previous[`${ny}-${nx}`] = [y, x];\n                queue.enqueue(neighbor, distance, count);\n\n                lastdir = [ny - y, nx - x];\n            }\n        }\n\n        setGrid(grid);\n    }\n}","/home/krug/Coding/Python/Pathfinding-Algorithms/website/src/algorithms/dijkstra.ts",[],[],{"ruleId":"55","severity":1,"message":"56","line":29,"column":50,"nodeType":"57","messageId":"58","endLine":29,"endColumn":111},"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'lastdir', 'lastdir'.","ArrowFunctionExpression","unsafeRefs"]