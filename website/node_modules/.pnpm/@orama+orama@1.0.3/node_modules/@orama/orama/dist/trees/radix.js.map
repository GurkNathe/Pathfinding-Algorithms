{"version":3,"sources":["../../src/trees/radix.ts"],"sourcesContent":["import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { Nullable } from '../types.js'\nimport { getOwnProperty, syncUniqueId } from '../utils.js'\n\nexport interface Node {\n  id: string\n  key: string\n  subWord: string\n  parent: Nullable<string>\n  children: Record<string, Node>\n  docs: string[]\n  end: boolean\n  word: string\n}\n\ntype FindParams = {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, string[]>\n\n/* c8 ignore next 5 */\nfunction serialize(this: Node): object {\n  const { word, subWord, children, docs, end } = this\n\n  return { word, subWord, children, docs, end }\n}\n\nfunction updateParent(node: Node, parent: Node): void {\n  node.parent = parent.id\n  node.word = parent.word + node.subWord\n}\n\nfunction addDocument(node: Node, docID: string): void {\n  node.docs.push(docID)\n}\n\nfunction removeDocument(node: Node, docID: string): boolean {\n  const index = node.docs.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.docs.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords(node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.end) {\n    const { word, docs: docIDs } = node\n\n    if (exact && word !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (!getOwnProperty(output, word)) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - word.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {\n          output[word] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[word] = []\n      }\n    }\n\n    // check if _output[word] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/OramaSearch/orama/issues/137\n    if (getOwnProperty(output, word) && docIDs.length) {\n      const docs = new Set(output[word])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[word] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.children)) {\n    findAllWords(node.children[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix(a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create(end = false, subWord = '', key = ''): Node {\n  const node = {\n    id: syncUniqueId(),\n    key,\n    subWord,\n    parent: null,\n    children: {},\n    docs: [],\n    end,\n    word: '',\n  }\n\n  Object.defineProperty(node, 'toJSON', { value: serialize })\n  return node\n}\n\nexport function insert(root: Node, word: string, docId: string) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.children[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.subWord\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.end = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix]\n        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.key = edgeLabelAtCommonPrefix\n\n        root.children[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.children[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.key = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.children[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.children[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nexport function find(root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // find the closest node to the term\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      const edgeLabel = rootChildCurrentChar.subWord\n      const termSubstring = term.substring(i)\n\n      // find the common prefix between two words ex: prime and primate = prim\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n      // if the common prefix lenght is equal to edgeLabel lenght (the node subword) it means they are a match\n      // if the common prefix is equal to the term means it is contained in the node\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        // if tolerance is set we take the current node as the closest\n        if (tolerance) break\n        return {}\n      }\n\n      // skip the subword lenght and check the next divergent character\n      i += rootChildCurrentChar.subWord.length - 1\n      // navigate into the child node\n      root = rootChildCurrentChar\n    } else {\n      return {}\n    }\n  }\n\n  const output: FindResult = {}\n  // found the closest node we recursively search through children\n  findAllWords(root, output, term, exact, tolerance)\n\n  return output\n}\n\nexport function contains(root: Node, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n\n    if (character in root.children) {\n      const rootChildrenChar = root.children[character]\n      const edgeLabel = rootChildrenChar.subWord\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.subWord.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord(root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.children) {\n      i += root.children[character].subWord.length - 1\n      root = root.children[character]\n\n      if (Object.keys(root.children).length === 0) {\n        delete parent.children[root.key]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord(root: Node, term: string, docID: string, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i]\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character]\n      i += rootChildCurrentChar.subWord.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.word !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n"],"names":["syncBoundedLevenshtein","getOwnProperty","syncUniqueId","serialize","word","subWord","children","docs","end","updateParent","node","parent","id","addDocument","docID","push","removeDocument","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","difference","Math","abs","length","isBounded","Set","docIDsLength","i","add","Array","from","character","Object","keys","getCommonPrefix","a","b","commonPrefix","len","min","create","key","defineProperty","value","insert","root","docId","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","find","termSubstring","contains","rootChildrenChar","removeWord","removeDocumentByWord"],"mappings":"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"}