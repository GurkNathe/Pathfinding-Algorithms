{"version":3,"sources":["../../src/components/levenshtein.ts"],"sourcesContent":["export type BoundedMetric = {\n  isBounded: boolean\n  distance: number\n}\n\n/**\n * Inspired by:\n * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340\n */\nfunction _boundedLevenshtein(a: string, b: string, tolerance: number): number {\n  // the strings are the same\n  if (a === b) {\n    return 0\n  }\n\n  // a should be the shortest string\n  const swap = a\n  if (a.length > b.length) {\n    a = b\n    b = swap\n  }\n\n  let lenA = a.length\n  let lenB = b.length\n\n  // ignore common suffix\n  // note: `~-` decreases by a unit in a bitwise fashion\n  while (lenA > 0 && a.charCodeAt(~-lenA) === b.charCodeAt(~-lenB)) {\n    lenA--\n    lenB--\n  }\n\n  // early return when the smallest string is empty\n  if (!lenA) {\n    return lenB > tolerance ? -1 : lenB\n  }\n\n  // ignore common prefix\n  let startIdx = 0\n  while (startIdx < lenA && a.charCodeAt(startIdx) === b.charCodeAt(startIdx)) {\n    startIdx++\n  }\n  lenA -= startIdx\n  lenB -= startIdx\n\n  // early return when the smallest string is empty\n  if (lenA === 0) {\n    return lenB > tolerance ? -1 : lenB\n  }\n\n  const delta = lenB - lenA\n\n  if (tolerance > lenB) {\n    tolerance = lenB\n  } else if (delta > tolerance) {\n    return -1\n  }\n\n  let i = 0\n  const row = []\n  const characterCodeCache = []\n\n  while (i < tolerance) {\n    characterCodeCache[i] = b.charCodeAt(startIdx + i)\n    row[i] = ++i\n  }\n\n  while (i < lenB) {\n    characterCodeCache[i] = b.charCodeAt(startIdx + i)\n    row[i++] = tolerance + 1\n  }\n\n  const offset = tolerance - delta\n  const haveMax = tolerance < lenB\n\n  let jStart = 0\n  let jEnd = tolerance\n\n  let current = 0\n  let left = 0\n  let above = 0\n  let charA = 0\n  let j = 0\n\n  // Starting the nested loops\n  for (i = 0; i < lenA; i++) {\n    left = i\n    current = i + 1\n\n    charA = a.charCodeAt(startIdx + i)\n    jStart += i > offset ? 1 : 0\n    jEnd += jEnd < lenB ? 1 : 0\n\n    for (j = jStart; j < jEnd; j++) {\n      above = current\n\n      current = left\n      left = row[j]\n\n      if (charA !== characterCodeCache[j]) {\n        // insert current\n        if (left < current) {\n          current = left\n        }\n\n        // delete current\n        if (above < current) {\n          current = above\n        }\n\n        current++\n      }\n\n      row[j] = current\n    }\n\n    if (haveMax && row[i + delta] > tolerance) {\n      return -1\n    }\n  }\n\n  return current <= tolerance ? current : -1\n}\n\n/**\n * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance\n * is greater than the given tolerance.\n * It assumes that:\n * - tolerance >= ||a| - |b|| >= 0\n */\nexport async function boundedLevenshtein(a: string, b: string, tolerance: number): Promise<BoundedMetric> {\n  const distance = _boundedLevenshtein(a, b, tolerance)\n  return {\n    distance,\n    isBounded: distance >= 0,\n  }\n}\n\n// This is only used internally, keep in sync with the previous one\nexport function syncBoundedLevenshtein(a: string, b: string, tolerance: number): BoundedMetric {\n  const distance = _boundedLevenshtein(a, b, tolerance)\n  return {\n    distance,\n    isBounded: distance >= 0,\n  }\n}\n\nexport function levenshtein(a: string, b: string): number {\n  /* c8 ignore next 3 */\n  if (!a.length) {\n    return b.length\n  }\n\n  /* c8 ignore next 3 */\n  if (!b.length) {\n    return a.length\n  }\n\n  const swap = a\n  if (a.length > b.length) {\n    a = b\n    b = swap\n  }\n\n  const row = Array.from({ length: a.length + 1 }, (_, i) => i)\n  let val = 0\n\n  for (let i = 1; i <= b.length; i++) {\n    let prev = i\n\n    for (let j = 1; j <= a.length; j++) {\n      if (b[i - 1] === a[j - 1]) {\n        val = row[j - 1]\n      } else {\n        val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1))\n      }\n\n      row[j - 1] = prev\n      prev = val\n    }\n    row[a.length] = prev\n  }\n\n  return row[a.length]\n}\n"],"names":["_boundedLevenshtein","a","b","tolerance","swap","length","lenA","lenB","charCodeAt","startIdx","delta","i","row","characterCodeCache","offset","haveMax","jStart","jEnd","current","left","above","charA","j","boundedLevenshtein","distance","isBounded","syncBoundedLevenshtein","levenshtein","Array","from","_","val","prev","Math","min"],"mappings":"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"}