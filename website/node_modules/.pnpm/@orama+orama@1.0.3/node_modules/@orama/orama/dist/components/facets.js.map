{"version":3,"sources":["../../src/components/facets.ts"],"sourcesContent":["import type {\n  FacetResult,\n  FacetSorting,\n  FacetsParams,\n  NumberFacetDefinition,\n  Orama,\n  Schema,\n  SearchableValue,\n  StringFacetDefinition,\n  TokenScore,\n} from '../types.js'\nimport { getNested } from '../utils.js'\n\nfunction sortingPredicate(order: FacetSorting = 'desc', a: [string, number], b: [string, number]) {\n  if (order.toLowerCase() === 'asc') {\n    return a[1] - b[1]\n  } else {\n    return b[1] - a[1]\n  }\n}\n\nexport async function getFacets<S extends Schema>(\n  orama: Orama<{ Schema: S }>,\n  results: TokenScore[],\n  facetsConfig: FacetsParams,\n): Promise<FacetResult> {\n  const facets: FacetResult = {}\n  const allIDs = results.map(([id]) => id)\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const facetKeys = Object.keys(facetsConfig!)\n\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n\n  for (const facet of facetKeys) {\n    let values = {}\n\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const { ranges } = facetsConfig[facet] as NumberFacetDefinition\n      const tmp = []\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0])\n      }\n      values = Object.fromEntries(tmp)\n    }\n\n    facets[facet] = {\n      count: 0,\n      values,\n    }\n  }\n\n  const allDocsLength = allDocs.length\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i]\n\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.')\n        ? (await getNested<string>(doc!, facet))!\n        : (doc![facet] as SearchableValue)\n\n      const propertyType = properties[facet]\n      switch (propertyType) {\n        case 'number': {\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          calculateNumberFacet(ranges, facets[facet].values, facetValue as number)\n          break\n        }\n        case 'number[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          for (const v of facetValue as Array<number>) {\n            calculateNumberFacet(ranges, facets[facet].values, v, alreadyInsertedValues)\n          }\n          break\n        }\n        case 'boolean':\n        case 'string': {\n          calculateBooleanOrStringFacet(facets[facet].values, facetValue as string | boolean, propertyType)\n          break\n        }\n        case 'boolean[]':\n        case 'string[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string'\n          for (const v of facetValue as Array<string | boolean>) {\n            calculateBooleanOrStringFacet(facets[facet].values, v, innerType, alreadyInsertedValues)\n          }\n          break\n        }\n      }\n    }\n  }\n\n  for (const facet of facetKeys) {\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length\n\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig as StringFacetDefinition\n\n      facets[facet].values = Object.fromEntries(\n        Object.entries(facets[facet].values)\n          .sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b))\n          .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10),\n      )\n    }\n  }\n\n  return facets\n}\n\nfunction calculateNumberFacet(\n  ranges: NumberFacetDefinition['ranges'],\n  values: Record<string, number>,\n  facetValue: number,\n  alreadyInsertedValues?: Set<string>,\n) {\n  for (const range of ranges) {\n    const value = `${range.from}-${range.to}`\n    if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n      continue\n    }\n\n    if (facetValue >= range.from && facetValue <= range.to) {\n      if (values[value] === undefined) {\n        values[value] = 1\n      } else {\n        values[value]++\n\n        if (alreadyInsertedValues) {\n          alreadyInsertedValues.add(value)\n        }\n      }\n    }\n  }\n}\n\nfunction calculateBooleanOrStringFacet(\n  values: Record<string, number>,\n  facetValue: string | boolean,\n  propertyType: 'string' | 'boolean',\n  alreadyInsertedValues?: Set<string>,\n) {\n  // String or boolean based facets\n  const value = facetValue?.toString() ?? (propertyType === 'boolean' ? 'false' : '')\n  if (alreadyInsertedValues && alreadyInsertedValues.has(value)) {\n    return\n  }\n  values[value] = (values[value] ?? 0) + 1\n  if (alreadyInsertedValues) {\n    alreadyInsertedValues.add(value)\n  }\n}\n"],"names":["getNested","sortingPredicate","order","a","b","toLowerCase","getFacets","orama","results","facetsConfig","facets","allIDs","map","id","allDocs","documentsStore","getMultiple","data","docs","facetKeys","Object","keys","properties","index","getSearchablePropertiesWithTypes","facet","values","ranges","tmp","range","push","from","to","fromEntries","count","allDocsLength","length","i","doc","facetValue","includes","propertyType","calculateNumberFacet","alreadyInsertedValues","Set","v","calculateBooleanOrStringFacet","innerType","stringFacetDefinition","entries","sort","slice","offset","limit","value","has","undefined","add","toString"],"mappings":"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"}