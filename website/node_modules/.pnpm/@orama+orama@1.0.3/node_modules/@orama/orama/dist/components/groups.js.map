{"version":3,"sources":["../../src/components/groups.ts"],"sourcesContent":["import type { Orama, ScalarSearchableValue, TokenScore, GroupByParams, GroupResult, Result, Reduce } from '../types.js'\nimport { createError } from '../errors.js'\nimport { getNested, intersect } from '../utils.js'\n\ninterface PropertyGroup {\n  property: string\n  perValue: Record<\n    string,\n    {\n      indexes: number[]\n      count: number\n    }\n  >\n}\n\ninterface Group {\n  values: ScalarSearchableValue[]\n  indexes: number[]\n}\n\nconst DEFAULT_REDUCE: Reduce<Result[]> = {\n  reducer: (_, acc, res, index) => {\n    acc[index] = res\n    return acc\n  },\n  getInitialValue: (length) => Array.from({ length }),\n}\n\nconst ALLOWED_TYPES = ['string', 'number', 'boolean']\n\nexport async function getGroups<AggValue>(orama: Orama, results: TokenScore[], groupBy: GroupByParams<AggValue>): Promise<GroupResult<AggValue>> {\n  const properties = groupBy.properties\n  const propertiesLength = properties.length\n\n  const schemaProperties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i]\n    if (typeof schemaProperties[property] === 'undefined') {\n      throw createError('UNKNOWN_GROUP_BY_PROPERTY', property)\n    }\n    if (!ALLOWED_TYPES.includes(schemaProperties[property])) {\n      throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property])\n    }\n  }\n\n  const allIDs = results.map(([id]) => id)\n\n  // allDocs is already sorted by the sortBy algorithm\n  // We leverage on that to limit the number of documents returned\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const allDocsLength = allDocs.length\n\n  const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER\n\n  const listOfValues: ScalarSearchableValue[][] = []\n\n  // We want to understand which documents have which values\n  // and group them by the property and values\n  const g: Record<string, PropertyGroup> = {}\n  for (let i = 0; i < propertiesLength; i++) {\n    const groupByKey = properties[i]\n    const group: PropertyGroup = {\n      property: groupByKey,\n      perValue: {},\n    }\n\n    const values: Set<ScalarSearchableValue> = new Set()\n    for (let j = 0; j < allDocsLength; j++) {\n      const doc = allDocs[j]\n\n      const value = await getNested<ScalarSearchableValue>(doc as object, groupByKey)\n      // we don't want to consider undefined values\n      if (typeof value === 'undefined') {\n        continue\n      }\n      const keyValue = typeof value !== 'boolean' ? value : '' + value\n      if (typeof group.perValue[keyValue] === 'undefined') {\n        group.perValue[keyValue] = {\n          indexes: [],\n          count: 0,\n        }\n      }\n      if (group.perValue[keyValue].count >= returnedCount) {\n        // We stop early because for this value we react the limit\n        continue\n      }\n\n      // We use the index to keep track of the original order\n      group.perValue[keyValue].indexes.push(j)\n      group.perValue[keyValue].count++\n\n      values.add(value)\n    }\n\n    listOfValues.push(Array.from(values))\n\n    g[groupByKey] = group\n  }\n\n  const combinations = calculateCombination(listOfValues)\n  const combinationsLength = combinations.length\n\n  const groups: Group[] = []\n  for (let i = 0; i < combinationsLength; i++) {\n    const combination = combinations[i]\n    const combinationLength = combination.length\n\n    const group: Group = {\n      values: [],\n      indexes: [],\n    }\n    const indexes: number[][] = []\n    for (let j = 0; j < combinationLength; j++) {\n      const value = combination[j]\n      const property = properties[j]\n      indexes.push(g[property].perValue[typeof value !== 'boolean' ? value : '' + value].indexes)\n      group.values.push(value)\n    }\n    // We leverage on the index to sort the results by the original order\n    group.indexes = intersect(indexes).sort((a, b) => a - b)\n\n    // don't generate empty groups\n    if (group.indexes.length === 0) {\n      continue\n    }\n\n    groups.push(group)\n  }\n\n  const groupsLength = groups.length\n  const res: GroupResult<AggValue> = Array.from({ length: groupsLength })\n  for (let i = 0; i < groupsLength; i++) {\n    const group = groups[i]\n\n    const reduce = (groupBy.reduce || DEFAULT_REDUCE) as Reduce<AggValue>\n\n    const docs = group.indexes.map(index => {\n      return {\n        id: allIDs[index],\n        score: results[index][1],\n        document: allDocs[index]!,\n      }\n    })\n\n    const func = reduce.reducer.bind(null, group.values)\n    const initialValue = reduce.getInitialValue(group.indexes.length)\n    const aggregationValue = docs.reduce(func, initialValue)\n\n    res[i] = {\n      values: group.values,\n      result: aggregationValue,\n    }\n  }\n\n  return res\n}\n\nfunction calculateCombination(arrs: ScalarSearchableValue[][], index = 0): ScalarSearchableValue[][] {\n  if (index + 1 === arrs.length) return arrs[index].map(item => [item]);\n\n  const head = arrs[index];\n  const c = calculateCombination(arrs, index + 1);\n\n  const combinations = [];\n  for (const value of head) {\n    for (const combination of c) {\n      combinations.push([value, ...combination]);\n    }\n  }\n\n  return combinations;\n}\n"],"names":["createError","getNested","intersect","DEFAULT_REDUCE","reducer","_","acc","res","index","getInitialValue","length","Array","from","ALLOWED_TYPES","getGroups","orama","results","groupBy","properties","propertiesLength","schemaProperties","getSearchablePropertiesWithTypes","data","i","property","includes","join","allIDs","map","id","allDocs","documentsStore","getMultiple","docs","allDocsLength","returnedCount","maxResult","Number","MAX_SAFE_INTEGER","listOfValues","g","groupByKey","group","perValue","values","Set","j","doc","value","keyValue","indexes","count","push","add","combinations","calculateCombination","combinationsLength","groups","combination","combinationLength","sort","a","b","groupsLength","reduce","score","document","func","bind","initialValue","aggregationValue","result","arrs","item","head","c"],"mappings":"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"}