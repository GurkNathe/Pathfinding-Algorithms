{"version":3,"sources":["../../src/components/index.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  Node as AVLNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument,\n} from '../trees/avl.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument,\n} from '../trees/radix.js'\nimport {\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  IIndex,\n  OpaqueDocumentStore,\n  OpaqueIndex,\n  Orama,\n  ScalarSearchableType,\n  Schema,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  Tokenizer,\n  TokenScore,\n} from '../types.js'\nimport { intersect } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getInnerType, isArrayType } from './defaults.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: string]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: string[]\n  false: string[]\n}\n\nexport interface Index extends OpaqueIndex {\n  indexes: Record<string, RadixNode | AVLNode<number, string[]> | BooleanIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrencies: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<string, number | undefined>>\n}\n\nexport type DefaultIndex = IIndex<Index>\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: string,\n  tokens: string[],\n  docsCount: number,\n): Promise<void> {\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][id] = tokens.length\n  index.frequencies[prop][id] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: string,\n  tokens: string[],\n  token: string,\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][id]![token] = tf\n\n  if (!(token in index.tokenOccurrencies[prop])) {\n    index.tokenOccurrencies[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrencies[prop][token] = (index.tokenOccurrencies[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: string,\n  docsCount: number,\n): Promise<void> {\n  index.avgFieldLength[prop] =\n    (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][id]!) / (docsCount - 1)\n  index.fieldLengths[prop][id] = undefined\n  index.frequencies[prop][id] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrencies[prop][token]--\n}\n\nexport async function calculateResultScores<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<I, D, AggValue>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: string[],\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrencies = index.tokenOccurrencies[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrencies[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrencies = typeof oramaOccurrencies[term] === 'number' ? oramaOccurrencies[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const id = documentIDs[k]\n    const tf = oramaFrequencies?.[id]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrencies,\n      context.docsCount,\n      fieldLengths[id]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>,\n    )\n\n    scoreList.push([id, bm25])\n  }\n  return scoreList\n}\n\nexport async function create(\n  orama: Orama<{ Index: DefaultIndex }>,\n  schema: Schema,\n  index?: Index,\n  prefix = '',\n): Promise<Index> {\n  if (!index) {\n    index = {\n      indexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrencies: {},\n      avgFieldLength: {},\n      fieldLengths: {},\n    }\n  }\n\n  for (const [prop, type] of Object.entries(schema)) {\n    const typeActualType = typeof type\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeActualType === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, type as Schema, index, path)\n      continue\n    }\n\n    switch (type) {\n      case 'boolean':\n      case 'boolean[]':\n        index.indexes[path] = { true: [], false: [] }\n        break\n      case 'number':\n      case 'number[]':\n        index.indexes[path] = avlCreate<number, string[]>(0, [])\n        break\n      case 'string':\n      case 'string[]':\n        index.indexes[path] = radixCreate()\n        index.avgFieldLength[path] = 0\n        index.frequencies[path] = {}\n        index.tokenOccurrencies[path] = {}\n        index.fieldLengths[path] = {}\n        break\n      default:\n        throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : (type as unknown as string), path)\n    }\n\n    index.searchableProperties.push(path)\n    index.searchablePropertiesWithTypes[path] = type\n  }\n\n  return index\n}\n\nasync function insertScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  switch (schemaType) {\n    case 'boolean': {\n      const booleanIndex = index.indexes[prop] as BooleanIndex\n      booleanIndex[value ? 'true' : 'false'].push(id)\n      break\n    }\n    case 'number':\n      avlInsert(index.indexes[prop] as AVLNode<number, string[]>, value as number, [id])\n      break\n    case 'string': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n      await implementation.insertDocumentScoreParameters(index, prop, id, tokens, docsCount)\n\n      for (const token of tokens) {\n        await implementation.insertTokenScoreParameters(index, prop, id, tokens, token)\n\n        radixInsert(index.indexes[prop] as RadixNode, token, id)\n      }\n\n      break\n    }\n  }\n}\n\nexport async function insert(\n  implementation: DefaultIndex,\n  index: Index,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<void> {\n  if (!isArrayType(schemaType)) {\n    return insertScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  switch (schemaType) {\n    case 'number': {\n      avlRemoveDocument(index.indexes[prop] as AVLNode<number, string[]>, id, value)\n      return true\n    }\n    case 'boolean': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = (index.indexes[prop] as BooleanIndex)[booleanKey].indexOf(id)\n\n      ;(index.indexes[prop] as BooleanIndex)[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'string': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(index.indexes[prop] as RadixNode, token, id)\n      }\n\n      return true\n    }\n  }\n}\n\nexport async function remove(\n  implementation: DefaultIndex,\n  index: Index,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount,\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<Index, D, AggValue>,\n  index: Index,\n  prop: string,\n  term: string,\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrencies)) {\n    return []\n  }\n\n  // Performa the search\n  const rootNode = index.indexes[prop] as RadixNode\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(rootNode, { term, exact, tolerance })\n  const ids = new Set<string>()\n\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue>(\n  context: SearchContext<I, D, AggValue>,\n  index: Index,\n  filters: Record<string, boolean | ComparisonOperator>,\n): Promise<string[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, string[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc,\n    }),\n    {},\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]\n\n    if (typeof operation === 'boolean') {\n      const idx = index.indexes[param] as BooleanIndex\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      filtersMap[param].push(...filteredIDs)\n      continue\n    }\n\n    if (typeof operation === 'string' || Array.isArray(operation)) {\n      const idx = index.indexes[param] as RadixNode\n\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        const filteredIDsResults = radixFind(idx, { term: term[0], exact: true })\n        filtersMap[param].push(...Object.values(filteredIDsResults).flat())\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    const operationOpt = operationKeys[0] as keyof ComparisonOperator\n    const operationValue = operation[operationOpt]\n\n    const AVLNode = index.indexes[param] as AVLNode<number, string[]>\n\n    switch (operationOpt) {\n      case 'gt': {\n        const filteredIDs = avlGreaterThan(AVLNode, operationValue, false)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'gte': {\n        const filteredIDs = avlGreaterThan(AVLNode, operationValue, true)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'lt': {\n        const filteredIDs = avlLessThan(AVLNode, operationValue, false)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'lte': {\n        const filteredIDs = avlLessThan(AVLNode, operationValue, true)\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'eq': {\n        const filteredIDs = avlFind(AVLNode, operationValue) ?? []\n        filtersMap[param].push(...filteredIDs)\n        break\n      }\n      case 'between': {\n        const [min, max] = operationValue as number[]\n        const filteredIDs = avlRangeSearch(AVLNode, min, max)\n        filtersMap[param].push(...filteredIDs)\n      }\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  const result = intersect(Object.values(filtersMap)) as unknown as string[]\n\n  return result\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nexport async function load<R = unknown>(raw: R): Promise<Index> {\n  const {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths,\n  } = raw as Index\n\n  return {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths,\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths,\n  } = index\n\n  return {\n    indexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrencies,\n    avgFieldLength,\n    fieldLengths,\n  } as R\n}\n\nexport async function createIndex(): Promise<DefaultIndex> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save,\n  }\n}\n"],"names":["createError","create","avlCreate","find","avlFind","greaterThan","avlGreaterThan","insert","avlInsert","lessThan","avlLessThan","rangeSearch","avlRangeSearch","removeDocument","avlRemoveDocument","radixCreate","radixFind","radixInsert","removeDocumentByWord","radixRemoveDocument","intersect","BM25","getInnerType","isArrayType","insertDocumentScoreParameters","index","prop","id","tokens","docsCount","avgFieldLength","length","fieldLengths","frequencies","insertTokenScoreParameters","token","tokenFrequency","t","tf","tokenOccurrencies","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","term","ids","documentIDs","Array","from","oramaOccurrencies","oramaFrequencies","termOccurrencies","scoreList","documentIDsLength","k","bm25","params","relevance","push","orama","schema","prefix","indexes","searchableProperties","searchablePropertiesWithTypes","type","Object","entries","typeActualType","path","isArray","true","false","insertScalar","implementation","value","schemaType","language","tokenizer","booleanIndex","tokenize","innerSchemaType","elements","elementsLength","i","removeScalar","booleanKey","position","indexOf","splice","remove","search","rootNode","exact","tolerance","searchResult","Set","key","add","searchByWhereClause","filters","filterKeys","keys","filtersMap","reduce","acc","param","operation","idx","filteredIDs","toString","raw","flat","filteredIDsResults","values","operationKeys","operationOpt","operationValue","AVLNode","min","max","result","getSearchableProperties","getSearchablePropertiesWithTypes","load","save","createIndex"],"mappings":"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"}