{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import { Language } from './components/tokenizer/languages.js'\n\nexport type Nullable<T> = T | null\n\nexport type SingleOrArray<T> = T | T[]\n\nexport type SyncOrAsyncValue<T = void> = T | Promise<T>\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OpaqueIndex {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OpaqueDocumentStore {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OpaqueSorter {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Schema extends Record<string, SearchableType | Schema> {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Document extends Record<string, SearchableValue | Document | unknown> {}\n\nexport type ScalarSearchableType = 'string' | 'number' | 'boolean'\nexport type ArraySearchableType = 'string[]' | 'number[]' | 'boolean[]'\nexport type SearchableType = ScalarSearchableType | ArraySearchableType\n\nexport type ScalarSearchableValue = string | number | boolean\nexport type ArraySearchableValue = string[] | number[] | boolean[]\nexport type SearchableValue = ScalarSearchableValue | ArraySearchableValue\n\nexport type SortType = 'string' | 'number' | 'boolean'\nexport type SortValue = string | number | boolean\n\nexport type BM25Params = {\n  k?: number\n  b?: number\n  d?: number\n}\n\nexport type FacetSorting = 'asc' | 'desc' | 'ASC' | 'DESC'\n\nexport interface StringFacetDefinition {\n  limit?: number\n  offset?: number\n  sort?: FacetSorting\n}\n\nexport interface NumberFacetDefinition {\n  ranges: { from: number; to: number }[]\n}\n\nexport interface BooleanFacetDefinition {\n  true?: boolean\n  false?: boolean\n}\n\nexport type FacetsParams = Record<string, FacetDefinition>\n\nexport type FacetDefinition = StringFacetDefinition | NumberFacetDefinition | BooleanFacetDefinition\n\nexport type ReduceFunction<T, R extends Result = Result> =\n  (values: ScalarSearchableValue[], acc: T, value: R, index: number) => T\nexport type Reduce<T> = {\n  reducer: ReduceFunction<T>\n  getInitialValue: (elementCount: number) => T\n}\n\nexport type GroupByParams<T> = {\n  properties: string[]\n  maxResult?: number\n  reduce?: Reduce<T>\n}\n\nexport type ComparisonOperator = {\n  gt?: number\n  gte?: number\n  lt?: number\n  lte?: number\n  eq?: number\n  between?: [number, number]\n}\n\n/**\n * A custom sorter function item as [id, score, document].\n */\nexport type CustomSorterFunctionItem = [string, number, Document]\n\nexport type CustomSorterFunction = (a: CustomSorterFunctionItem, b: CustomSorterFunctionItem) => number\n/**\n * Define which properties to sort for.\n */\nexport type SorterParams = {\n  /**\n   * The key of the document used to sort the result.\n   */\n  property: string\n  /**\n   * Whether to sort the result in ascending or descending order.\n   */\n  order?: 'ASC' | 'DESC'\n}\n\nexport type SortByParams = SorterParams | CustomSorterFunction\n\nexport type SearchParams<T = Result[]> = {\n  /**\n   * The word to search.\n   */\n  term?: string\n  /**\n   * The properties of the document to search in.\n   */\n  properties?: '*' | string[]\n  /**\n   * The number of matched documents to return.\n   */\n  limit?: number\n  /**\n   * The number of matched documents to skip.\n   */\n  offset?: number\n  /**\n   * The key of the document used to sort the result.\n   */\n  sortBy?: SortByParams\n  /**\n   * Whether to match the term exactly.\n   */\n  exact?: boolean\n  /**\n   * The maximum [levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\n   * between the term and the searchable property.\n   */\n  tolerance?: number\n  /**\n   * The BM25 parameters to use.\n   *\n   * k: Term frequency saturation parameter.\n   * The higher the value, the more important the term frequency becomes.\n   * The default value is 1.2. It should be set to a value between 1.2 and 2.0.\n   *\n   * b: Document length saturation impact. The higher the value, the more\n   * important the document length becomes. The default value is 0.75.\n   *\n   * d: Frequency normalization lower bound. Default value is 0.5.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/BM25-algorithm\n   *\n   * @see https://en.wikipedia.org/wiki/Okapi_BM25\n   */\n  relevance?: BM25Params\n  /**\n   * The boost to apply to the properties.\n   *\n   * The boost is a number that is multiplied to the score of the property.\n   * It can be used to give more importance to some properties.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/fields-boosting\n   *\n   * @example\n   * // Give more importance to the 'title' property.\n   * const result = await search(db, {\n   *  term: 'Michael',\n   *  properties: ['title', 'author'],\n   *  boost: {\n   *   title: 2\n   *  }\n   * });\n   *\n   * // In that case, the score of the 'title' property will be multiplied by 2.\n   */\n  boost?: Record<string, number>\n  /**\n   * Facets configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/facets\n   *\n   * A facet is a feature that allows users to narrow down their search results by specific\n   * attributes or characteristics, such as category, price, or location.\n   * This can help users find more relevant and specific results for their search query.\n   *\n   * @example\n   *\n   * const results = await search(db, {\n   *  term: 'Personal Computer',\n   *  properties: ['title', 'description', 'category.primary', 'category.secondary'],\n   *  facets: {\n   *    'category.primary': {\n   *      size: 10,\n   *      sort: 'ASC',\n   *    }\n   *  }\n   * });\n   */\n  facets?: FacetsParams\n\n  /**\n   * Distinct configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/introduction#distinct\n   *\n   * @example\n   * const results = await search(db, {\n   *  term: 'Headphones',\n   *  distinctOn: 'category.primary',\n   * })\n   */\n  distinctOn?: string\n\n  /**\n   * Groups configuration\n   * Full documentation: https://docs.oramasearch.com/usage/search/grouping\n   *\n   * @example\n   * const results = await search(db, {\n   *  term: 'Headphones',\n   *  groupBy: {\n   *   properties: ['category.primary'],\n   *   maxResult: 10,\n   *  }\n   * })\n   */\n  groupBy?: GroupByParams<T>\n\n  /**\n   * Filter the search results.\n   * Full documentation: https://docs.oramasearch.com/usage/search/filters\n   *\n   * @example\n   * // Search for documents that contain 'Headphones' in the 'description' and 'title' fields and\n   * // have a price less than 100.\n   *\n   * const result = await search(db, {\n   *  term: 'Headphones',\n   *  properties: ['description', 'title'],\n   *  where: {\n   *    price: {\n   *      lt: 100\n   *    }\n   *  }\n   * });\n   */\n  where?: Record<string, boolean | string | string[] | ComparisonOperator>\n\n  /**\n   * Threshold to use for refining the search results.\n   * The threshold is a number between 0 and 1 that represents the minimum score of the documents to return.\n   * By default, the threshold is 1.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/threshold\n   *\n   * @example\n   *\n   * const result = await search(db, {\n   *  term: 'Red Headphones'\n   *  threshold: 0\n   * });\n   *\n   * // The result will contain all the documents that contain both 'Red' and 'Headphones' in their properties.\n   *\n   * const result2 = await search(db, {\n   *  term: 'Red Headphones'\n   *  threshold: 1\n   * });\n   *\n   * // The result will contain all the documents that contain either 'Red' and 'Headphones' in their properties.\n   */\n  threshold?: number\n\n  /**\n   * Preflight query.\n   * Will return just the facets (if needed) and the number of matched documents for the given query.\n   *\n   * Full documentation: https://docs.oramasearch.com/usage/search/preflight\n   *\n   * @example\n   *\n   * const result = await search(db, {\n   *  term: 'Red Headphones',\n   *  preflight: true\n   * });\n   *\n   * console.log(result);\n   *\n   * // {\n   * //   elapsed: {\n   * //     raw: 181208,\n   * //     formatted: '181Î¼s'\n   * //   },\n   * //   count: 100,\n   * // }\n   */\n  preflight?: boolean\n}\n\nexport type Result = {\n  /**\n   * The id of the document.\n   */\n  id: string\n  /**\n   * The score of the document in the search.\n   */\n  score: number\n  /**\n   * The document\n   */\n  document: Document\n}\n\nexport type FacetResult = Record<\n  string,\n  {\n    count: number\n    values: Record<string, number>\n  }\n>\n\nexport type GroupResult<T = Result[]> =\n  | {\n      values: ScalarSearchableValue[]\n      result: T\n    }[]\n\nexport type TokenScore = [string, number]\n\nexport type TokenMap = Record<string, TokenScore[]>\n\nexport type IndexMap = Record<string, TokenMap>\n\nexport type SearchContext<I extends OpaqueIndex, D extends OpaqueDocumentStore, AggValue = Result[]> = {\n  timeStart: bigint\n  tokenizer: Tokenizer\n  index: IIndex<I>\n  documentsStore: IDocumentsStore<D>\n  language: string | undefined\n  params: SearchParams<AggValue>\n  docsCount: number\n  uniqueDocsIDs: Record<string, number>\n  indexMap: IndexMap\n  docsIntersection: TokenMap\n}\n\nexport type ElapsedTime = {\n  raw: number\n  formatted: string\n}\n\nexport type Results<AggValue = Result[]> = {\n  /**\n   * The number of all the matched documents.\n   */\n  count: number\n  /**\n   * An array of matched documents taking `limit` and `offset` into account.\n   */\n  hits: Result[]\n  /**\n   * The time taken to search.\n   */\n  elapsed: ElapsedTime\n  /**\n   * The facets results.\n   */\n  facets?: FacetResult\n\n  groups?: GroupResult<AggValue>\n}\n\nexport type SingleCallbackComponent<A extends ProvidedTypes> = (\n  orama: Orama<A>,\n  id: string,\n  doc?: Document,\n) => SyncOrAsyncValue\n\nexport type MultipleCallbackComponent<A extends ProvidedTypes> = (\n  orama: Orama<A>,\n  doc: Document[] | string[],\n) => SyncOrAsyncValue\n\nexport type IIndexInsertOrRemoveHookFunction<I extends OpaqueIndex = OpaqueIndex, R = void> = (\n  index: I,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  type: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n) => SyncOrAsyncValue<R>\n\nexport interface IIndex<I extends OpaqueIndex = OpaqueIndex> {\n  create<S extends Schema, D extends OpaqueDocumentStore, So extends OpaqueSorter>(\n    orama: Orama<{ Schema: S; Index: I; DocumentStore: D; Sorter: So }>,\n    schema: Schema,\n  ): SyncOrAsyncValue<I>\n\n  beforeInsert?: IIndexInsertOrRemoveHookFunction<I>\n  insert: (\n    implementation: IIndex<I>,\n    index: I,\n    prop: string,\n    id: string,\n    value: SearchableValue,\n    schemaType: SearchableType,\n    language: string | undefined,\n    tokenizer: Tokenizer,\n    docsCount: number,\n  ) => SyncOrAsyncValue\n  afterInsert?: IIndexInsertOrRemoveHookFunction<I>\n\n  beforeRemove?: IIndexInsertOrRemoveHookFunction<I>\n  remove: (\n    implementation: IIndex<I>,\n    index: I,\n    prop: string,\n    id: string,\n    value: SearchableValue,\n    schemaType: SearchableType,\n    language: string | undefined,\n    tokenizer: Tokenizer,\n    docsCount: number,\n  ) => SyncOrAsyncValue<boolean>\n  afterRemove?: IIndexInsertOrRemoveHookFunction<I>\n\n  insertDocumentScoreParameters(\n    index: I,\n    prop: string,\n    id: string,\n    tokens: string[],\n    docsCount: number,\n  ): SyncOrAsyncValue\n  insertTokenScoreParameters(index: I, prop: string, id: string, tokens: string[], token: string): SyncOrAsyncValue\n  removeDocumentScoreParameters(index: I, prop: string, id: string, docsCount: number): SyncOrAsyncValue\n  removeTokenScoreParameters(index: I, prop: string, token: string): SyncOrAsyncValue\n  calculateResultScores<D extends OpaqueDocumentStore, AggValue = Result[]>(\n    context: SearchContext<I, D, AggValue>,\n    index: I,\n    prop: string,\n    term: string,\n    ids: string[],\n  ): SyncOrAsyncValue<TokenScore[]>\n\n  search<D extends OpaqueDocumentStore, AggValue = Result[]>(\n    context: SearchContext<I, D, AggValue>,\n    index: I,\n    prop: string,\n    term: string,\n  ): SyncOrAsyncValue<TokenScore[]>\n  searchByWhereClause<D extends OpaqueDocumentStore, AggValue = Result[]>(\n    context: SearchContext<I, D, AggValue>,\n    index: I,\n    filters: Record<string, boolean | string | string[] | ComparisonOperator>,\n  ): SyncOrAsyncValue<string[]>\n\n  getSearchableProperties(index: I): SyncOrAsyncValue<string[]>\n  getSearchablePropertiesWithTypes(index: I): SyncOrAsyncValue<Record<string, SearchableType>>\n\n  load<R = unknown>(raw: R): SyncOrAsyncValue<I>\n  save<R = unknown>(index: I): SyncOrAsyncValue<R>\n}\n\nexport interface IDocumentsStore<D extends OpaqueDocumentStore = OpaqueDocumentStore> {\n  create<S extends Schema, I extends OpaqueIndex, So extends OpaqueSorter>(\n    orama: Orama<{ Schema: S; Index: I; DocumentStore: D; Sorter: So }>,\n  ): SyncOrAsyncValue<D>\n  get(store: D, id: string): SyncOrAsyncValue<Document | undefined>\n  getMultiple(store: D, ids: string[]): SyncOrAsyncValue<(Document | undefined)[]>\n  getAll(store: D): SyncOrAsyncValue<Record<string, Document>>\n  store(store: D, id: string, doc: Document): SyncOrAsyncValue<boolean>\n  remove(store: D, id: string): SyncOrAsyncValue<boolean>\n  count(store: D): SyncOrAsyncValue<number>\n\n  load<R = unknown>(raw: R): SyncOrAsyncValue<D>\n  save<R = unknown>(store: D): SyncOrAsyncValue<R>\n}\n\nexport interface SorterConfig {\n  enabled?: boolean\n  unsortableProperties?: string[]\n}\n\nexport interface ISorter<So extends OpaqueSorter = OpaqueSorter> {\n  create<S extends Schema, I extends OpaqueIndex, D extends OpaqueDocumentStore>(\n    orama: Orama<{ Schema: S; Index: I; DocumentStore: D; Sorter: So }>,\n    schema: Schema,\n    sorterConfig?: SorterConfig,\n  ): SyncOrAsyncValue<So>\n  insert: (\n    sorter: So,\n    prop: string,\n    id: string,\n    value: SortValue,\n    schemaType: SortType,\n    language: string | undefined,\n  ) => SyncOrAsyncValue\n  remove: (sorter: So, prop: string, id: string) => SyncOrAsyncValue\n\n  load<R = unknown>(raw: R): SyncOrAsyncValue<So>\n  save<R = unknown>(sorter: So): SyncOrAsyncValue<R>\n\n  sortBy(sorter: So, docIds: [string, number][], by: SorterParams): Promise<[string, number][]>\n\n  getSortableProperties(sorter: So): SyncOrAsyncValue<string[]>\n  getSortablePropertiesWithTypes(sorter: So): SyncOrAsyncValue<Record<string, SortType>>\n}\n\nexport type Stemmer = (word: string) => string\n\nexport type DefaultTokenizerConfig = {\n  language?: Language\n  stemming?: boolean\n  stemmer?: Stemmer\n  stemmerSkipProperties?: string | string[]\n  stopWords?: boolean | string[] | ((stopWords: string[]) => string[] | Promise<string[]>)\n  allowDuplicates?: boolean\n}\n\nexport interface Tokenizer {\n  language: string\n  normalizationCache: Map<string, string>\n  tokenize: (raw: string, language?: string, prop?: string) => SyncOrAsyncValue<string[]>\n}\n\nexport interface ObjectComponents<I extends OpaqueIndex, D extends OpaqueDocumentStore, So extends OpaqueSorter> {\n  tokenizer: Tokenizer | DefaultTokenizerConfig\n  index: I\n  documentsStore: D\n  sorter: So\n}\n\nexport interface FunctionComponents<S extends Schema = Schema> {\n  validateSchema(doc: Document, schema: S): SyncOrAsyncValue<string | undefined>\n  getDocumentIndexId(doc: Document): SyncOrAsyncValue<string>\n  getDocumentProperties(doc: Document, paths: string[]): SyncOrAsyncValue<Record<string, string | number | boolean>>\n  formatElapsedTime(number: bigint): SyncOrAsyncValue<number | string | object | ElapsedTime>\n}\n\nexport interface SingleOrArrayCallbackComponents<A extends ProvidedTypes> {\n  beforeInsert: SingleOrArray<SingleCallbackComponent<A>>\n  afterInsert: SingleOrArray<SingleCallbackComponent<A>>\n  beforeRemove: SingleOrArray<SingleCallbackComponent<A>>\n  afterRemove: SingleOrArray<SingleCallbackComponent<A>>\n  beforeUpdate: SingleOrArray<SingleCallbackComponent<A>>\n  afterUpdate: SingleOrArray<SingleCallbackComponent<A>>\n  beforeMultipleInsert: SingleOrArray<MultipleCallbackComponent<A>>\n  afterMultipleInsert: SingleOrArray<MultipleCallbackComponent<A>>\n  beforeMultipleRemove: SingleOrArray<MultipleCallbackComponent<A>>\n  afterMultipleRemove: SingleOrArray<MultipleCallbackComponent<A>>\n  beforeMultipleUpdate: SingleOrArray<MultipleCallbackComponent<A>>\n  afterMultipleUpdate: SingleOrArray<MultipleCallbackComponent<A>>\n}\n\nexport interface ArrayCallbackComponents<A extends ProvidedTypes> {\n  beforeInsert: SingleCallbackComponent<A>[]\n  afterInsert: SingleCallbackComponent<A>[]\n  beforeRemove: SingleCallbackComponent<A>[]\n  afterRemove: SingleCallbackComponent<A>[]\n  beforeUpdate: SingleCallbackComponent<A>[]\n  afterUpdate: SingleCallbackComponent<A>[]\n  beforeMultipleInsert: MultipleCallbackComponent<A>[]\n  afterMultipleInsert: MultipleCallbackComponent<A>[]\n  beforeMultipleRemove: MultipleCallbackComponent<A>[]\n  afterMultipleRemove: MultipleCallbackComponent<A>[]\n  beforeMultipleUpdate: MultipleCallbackComponent<A>[]\n  afterMultipleUpdate: MultipleCallbackComponent<A>[]\n}\n\nexport type Components<A extends ProvidedTypes> = Partial<\n  ObjectComponents<A['Index'], A['DocumentStore'], A['Sorter']> &\n    FunctionComponents &\n    SingleOrArrayCallbackComponents<A>\n>\n\nexport const kInsertions = Symbol('orama.insertions')\nexport const kRemovals = Symbol('orama.removals')\n\ninterface Data<I extends OpaqueIndex, D extends OpaqueDocumentStore, S extends OpaqueSorter> {\n  index: I\n  docs: D\n  sorting: S\n}\n\ntype Internals<A extends ProvidedTypes> = {\n  schema: A['Schema']\n  tokenizer: Tokenizer\n  index: IIndex<A['Index']>\n  documentsStore: IDocumentsStore<A['DocumentStore']>\n  sorter: ISorter<A['Sorter']>\n  data: Data<A['Index'], A['DocumentStore'], A['Sorter']>\n  caches: Record<string, unknown>\n  [kInsertions]: number | undefined\n  [kRemovals]: number | undefined\n}\n\ntype OramaID = {\n  id: string\n}\n\nexport type ProvidedTypes = {\n  Schema: Schema\n  Index: OpaqueIndex\n  DocumentStore: OpaqueDocumentStore\n  Sorter: OpaqueSorter\n}\n\ntype RequiredInner<T extends Partial<ProvidedTypes>> = {\n  [Key in keyof ProvidedTypes]: Key extends keyof ProvidedTypes\n    ? ProvidedTypes[Key]\n    : Key extends keyof T\n    ? T[Key]\n    : never\n}\n\nexport type Orama<\n  A extends Partial<ProvidedTypes> = {\n    Schema: Schema\n    Index: OpaqueIndex\n    DocumentStore: OpaqueDocumentStore\n    Sorter: OpaqueSorter\n  },\n> = FunctionComponents & ArrayCallbackComponents<RequiredInner<A>> & Internals<RequiredInner<A>> & OramaID\n"],"names":["kInsertions","Symbol","kRemovals"],"mappings":"AA6jBA,OAAO,MAAMA,cAAcC,OAAO,oBAAmB;AACrD,OAAO,MAAMC,YAAYD,OAAO,kBAAiB"}